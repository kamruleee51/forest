%% forest-doc.tex
%% `forest-doc.tex` is a main documentation source of package `forest`.
%%
%% Copyright (c) 2015 Saso Zivanovic
%%                    (Sa\v{s}o \v{Z}ivanovi\'{c})
%% saso.zivanovic@guest.arnes.si
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%% 
%%   http://www.latex-project.org/lppl.txt
%%   
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%% 
%% This work has the LPPL maintenance status `author-maintained'.
%% 
%% This file is a part of package `forest'. For the list of files
%% constituting the package see main source file of the package,
%% `forest.dtx', or the derived `forest.sty'.
%%
\documentclass{ltxdoc}
\usepackage[a4paper,
  top=2cm,bottom=2.5cm,
  reversemarginpar,marginparwidth=2cm,
  right=1.5cm,
  nohead
]{geometry}

%\immediate\write18{makeindex -s forest-doc.ist forest-doc}
\def\indexlettertotoc#1\relax{%
  \phantomsection\addcontentsline{toc}{subsection}{#1}%
  #1%
}
\makeatletter
\c@IndexColumns=2 \makeatother
\IndexPrologue{Color legend: \textcolor{red}{definition}, \textcolor{darkgreen}{example}, \textcolor{blue}{other}. If an entry belongs to a library, the library name is given in parenthesis. All page numbers are hyperlinks, and definitions in text are hyperlinked to this index.}
\makeindex

\usepackage[external]{forest}
\useforestlibrary{edges}
\useforestlibrary{linguistics}
% \tikzexternalize
% forest-tikzexternalize either contains \tikzexternalize or not ... make adjusts this
\IfFileExists{forest-doc.tex-externalize.tex}{%
  \input forest-doc.tex-externalize
}{}
\tikzset{
  external/prefix={forest.for.dir/},
  external/system call={
    pdflatex \tikzexternalcheckshellescape -halt-on-error -interaction=nonstopmode
    -jobname "\image" "\texsource"},
  external/up to date check=simple,
}

\usepackage{forest-doc} 

\usepackage{hyperref}
\hypersetup{unicode=true,colorlinks=true,linkcolor=blue,citecolor=blue,hyperindex=false}
\usepackage{url}
\usepackage[numbers]{natbib}
\usepackage[multiple]{footmisc}
\usepackage{tipa}
\usepackage[inline,shortlabels]{enumitem}
\newlist{compactitem}{itemize}{2}
\setlist[compactitem]{nosep,label=\textbullet}
\newlist{arguments}{enumerate}{1}
\setlist[arguments]{nosep,label=\textbf{\#\arabic*}}
\renewcommand\DescribeMacro[1]{\texttt{\detokenize{#1}}\marginpar{\hfill\small\strut\texttt{\detokenize{#1}}}}
\usepackage{printlen}
\usepackage{tabularx}
\DeleteShortVerb\|
\newcommand\OR{\ensuremath{\,|\,}}%
\usepackage{multicol}

%\usepackage[silent]{trace-pgfkeys} % silent, stack, trace, verbose
%\pgfkeystracelevel{trace}

  %%% begin listing region: index_macro_style
\forestset{
  detokenize/.style={result=\protect\detokenize{##1}},
  tt/.style={result=\protect\texttt{##1}},
  macro/.style={detokenize, +result={\char\escapechar}, tt, print in color, hyper},
}
  %%% end listing region: index_macro_style
\forestset{
  pgfkey/.style={tt,print in color,hyper},
  path/.style={+result={/},pgfkey},
  handler/.style={+result={.},pgfkey},
  option value/.style={
    format={tt,result+={ value}},
    for first={format=pgfkey},
  },
  environment/.style={
    detokenize,
    tt,
    print in color,
    if stage={index}{}{
      if index entry type={definition}{
        temptoksa/.register=result,
        hyper,
        result/.wrap 2 pgfmath args={%
          \texttt{\string\begin\char`\{##1\char`\}}%
            \forestoption{argument}%
            \texttt{\string\end\char`\{##2\char`\}}%
        }{result}{temptoksa},
      }{
        hyper
      }
    }
  },
  empty/.style={result={{}}},
  meta/.style={result=\protect\meta{##1},print in color,hyper},
  index library/.style={
    if index entry type={definition}{
        for first leaf'={
          index format+={
            result+'={\space
              {\protect\scriptsize
                (\protect\texttt{\protect\hyperrefnocolor[sec:library-#1]{#1}})%
              }%
            }
          }
      },
    }{}
  },
  margin/.style={print format={result=\marginpar{\strut##1}}},
  also margin/.style={print format={result=##1\marginpar{\strut##1}}},
}

\let\origmeta\meta
\renewcommand\meta[1]{\origmeta{\rm\ignorespaces#1}}
\renewcommand\rstyle{\color{red}}
\newcommand\hyperrefnocolor[2][]{{\hypersetup{linkcolor=black}\hyperref[#1]{#2}}}
\newcommand\librarysection[1]{%
  \subsection{\protect\texttt{#1}}%
  \label{sec:library-#1}%
  \forestset{every index end/.style={set={index library={#1}}}}%
}
\newcommand\reflibrary[1]{\hyperref[sec:library-#1]{\texttt{#1}}}

\index[not print,not index,set={
  index key=unknown,
  form={\textbf{unknown!!}},
  for first={format={
      result/.expanded=\noexpand\textbf{\forestregister{result}??},
      print in color}}}
  ]>{@unknown}

\indexset
  [print form={},for first={format=pgfkey}]
  >{node key}

\indexset
  [for first={format={+result={/tikz/},pgfkey}}]
  >{tikz key}

\indexset
  [for first={format=pgfkey}]
  >{option,readonly option,bracket key,nodewalk key,register,propagator,style,nodewalk style,stage,dynamic tree,step,loop,conditional,anchor,package option}
 
  %%% begin listing region: index_macro_category
\indexset
  [for first={format=macro}]
  >{macro}
  %%% end listing region: index_macro_category

\indexset
  [for first={format=environment}]
  >{environment}

\indexset
  [format=empty]>{empty}

\indexset
  [index form={type (of options and registers)},for first={format=meta}]
  >{type}

\indexset
  [for first={format=handler}]
  >{handler}

\indexset
  [format={aggregate function},for first={format=handler}]
  >{aggregate}

\indexset
  [form={\texttt{pgfmath} function},for first={format={pgfkey}}]
  >{pgfmath}

\indexset
  [for first={format=path}]
  >{path}

\indexset[
    form={},
    for first={
      for first={
        key+/.pgfmath=argument("!parent"),
        index format={
          result+/.wrap pgfmath arg={\protect\meta{##1 option}}{argument("!parent")}
        },
        print format={
          if argument={}{}{
            result+/.option=argument
          },
        },
        format={
          pgfkey
        },
      }
    }
  ]>{prefix}

\indexset[
    form={},
    for first={
      for first={
        +key/.pgfmath=argument("!parent"),
        index format={
          +result/.wrap pgfmath arg={\protect\meta{##1 option}}{argument("!parent")}
        },
        print format={
          if argument={}{}{
            +result/.option=argument
          },
        },
        format={
          pgfkey
        },
      }
    }
  ]>{suffix}
  
\indexset[
    form={},
    for first={
      for first={
        key/.wrap 2 pgfmath args={##1 ##2}{key}{argument("!parent,parent")},
        index format={
          result+={\space},
          result+/.wrap pgfmath arg={\protect\meta{##1}}{argument("!parent,parent")}
        },
        print format={
          if argument={}{}{
            result+={\space},
            result+/.option=argument
          }
        },
        format={
          pgfkey
        },
      }
    }
  ]>{word prefix}

\indexset[
    form={},
    for first={
      for first={
        key/.wrap 2 pgfmath args={##2 ##1}{key}{argument("!parent,parent")},
        index format={
          +result={\space},
          +result/.wrap pgfmath arg={\protect\meta{##1}}{argument("!parent,parent")}
        },
        print format={
          if argument={}{}{
            +result={\space},
            +result/.option=argument
          }
        },
        format={
          pgfkey
        },
      }
    }
  ]>{word suffix}
  
\indexset[%option values
  index key format={result/.expanded=\forestoption{argument} value},
  format={result/.expanded=\noexpand\texttt{\forestoption{argument}} value},
  for first={format=pgfkey}
  ]>{value} 

\indexset[
  index key format={result/.expanded=\forestoption{argument} option},
  format={result/.expanded=\noexpand\texttt{\forestoption{argument}} option},
  for first={format=pgfkey}
  ]>{option of}
  
\indexset
  [form={},for first={format=meta}]
  >{meta}

\indexset[
    for first={+key={{cs }},format={pgfkey}}
  ]>{forest cs}

\indexset[
    for first={+key={{ss }},format={pgfkey}}
  ]>{short step}


  
{\makeatletter % an dirty patch: \lst@nolig can sneak in the name...
\gdef\myexampleindex#1{{\def\lst@nolig{}\lstaspectindex{#1}{}}}
}
\lstset{indexstyle={[1]\myexampleindex}}
%%% end lst-related stuff

\EnableCrossrefs         
\setlength\hfuzz{15pt}  % dont make so many
\hbadness=7000          % over and under full box warnings

\usetikzlibrary{intersections}
\tikzset{>=latex}
\forestset{
  background tree/.style={
    for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}}
}

\title{\FoRest;: a \PGF;/\TikZ;-based package for drawing linguistic trees\\\normalsize\forestversion}
\author{Sa\v so \v Zivanovi\'c\footnote{e-mail:
    \href{mailto:saso.zivanovic@guest.arnes.si}{saso.zivanovic@guest.arnes.si};
    web:
    \href{http://spj.ff.uni-lj.si/zivanovic/}{http://spj.ff.uni-lj.si/zivanovic/}}}

%\usepackage[trace]{trace-pgfkeys} % silent, stack, trace, verbose
%\pgfkeystracelevel{trace}

\begin{document}

\typeout{)}% hacking auctex's error finding routing

% short verbatim: | (changes spaces into _)
\DeleteShortVerb\|
{\catcode`\_=12 \def\marshal{%
\lstMakeShortInline[basicstyle=\ttfamily,literate={_}{ }1 {__}{_}1]}%
\expandafter}\marshal |

\IfFileExists{forest-doc-test.tex}{%
  \input{forest-doc-test}
}{}

\newbox\treebox
\newbox\codebox

{\settodayfromforestdate\maketitle}

\begin{abstract}
\FoRest; is a \PGF;/\TikZ;-based package for drawing linguistic (and
other kinds of) trees.  Its main features are 
\begin{enumerate*}[(i)]
\item a packing algorithm which can produce very compact trees;
\item a user-friendly interface consisting of the familiar bracket encoding of trees plus the
  key--value interface to option-setting;
\item many tree-formatting options, with control over option values of individual nodes and
  mechanisms for their manipulation;
\item a powerful mechanism for travesing the tree;
\item the possibility to decorate the tree using the full power of \PGF;/\TikZ;;
\item an externalization mechanism sensitive to code-changes.
\end{enumerate*}
\end{abstract}

\vspace{1cm}

\begin{forestexample}[basicstyle=\ttfamily\scriptsize,layout=tree on top,no label,v sep=1cm,index={content,pgfmath,propagator>if,repeat,append,before drawing tree,y,alias,for step,step>children,edge,before typesetting nodes,tree,s sep,dimen+,l,ancestors,typeset node,nodewalk,option>level,sort by,step>min}]
  \pgfmathsetseed{14285}
  \begin{forest}
    random tree/.style n args={3}{% #1 = max levels, #2 = max children, #3 = max content
      content/.pgfmath={random(0,#3)},
      if={#1>0}{repeat={random(0,#2)}{append={[,random tree={#1-1}{#2}{#3}]}}}{}},
    before typesetting nodes={for tree={draw,s sep=2pt,rotate={int(30*rand)},l+={5*rand},
                                        if={isodd(level())}{fill=green}{fill=yellow}}},
    important/.style={draw=red,line width=1.5pt,edge={red,line width=1.5pt}},
    before drawing tree={sort by=y, for nodewalk={min=tree,ancestors}{important,typeset node}}
    [,random tree={9}{3}{100}]
  \end{forest}
 \end{forestexample}%
 \begin{center}\mbox{}\box\treebox\\\box\codebox\end{center}

\newpage
{%
  \parskip 0pt
  \begin{multicols}{2}
    \tableofcontents
  \end{multicols}
}

\newpage

\section{Introduction}

Over several years, I had been a grateful user of various packages
for typesetting linguistic trees.  My main experience was with
|qtree| and |synttree|, but as far as I can tell, all of the tools
on the market had the same problem: sometimes, the trees were just
too wide.  They looked something like the tree on the left,
while I wanted something like the tree on the right.
\begin{center}
  \begin{forest}
    baseline,
    for tree={parent anchor=south,child anchor=north,l=7ex,s sep=10pt},
    for children={fit=rectangle}
    [CP
      [DP
        [D][NP[N][CP[C][TP[T][vP[v][VP[DP][V'[V][DP]]]]]]]]
      [TP
        [T][vP[v][VP[DP][V'[V][DP]]]]]
    ]
  \end{forest}
  \hfill
  \begin{forest}
    baseline,
    for tree={parent anchor=south,child anchor=north,l=7ex,s sep=10pt},
    [CP
      [DP
        [D][NP[N][CP[C][TP[T][vP[v][VP[DP][V'[V][DP]]]]]]]]
      [TP
        [T][vP[v][VP[DP][V'[V][DP]]]]]
    ]
  \end{forest}
\end{center}

Luckily, it was possible to tweak some parameters by hand to get a
narrower tree, but as I quite dislike constant manual adjustments, I
eventually started to develop \foRest;.  It started out as
|xyforest|, but lost the |xy| prefix as I became increasingly fond
of \PGF;/\TikZ;, which offered not only a drawing package but also a
`programming paradigm.'  It is due to the awesome power of the
supplementary facilities of \PGF;/\TikZ; that \foRest; is now, I
believe, the most flexible tree typesetting package for \LaTeX\ you can get. 

The latest stable version of \FoRest; is \href{http://www.ctan.org/pkg/forest}{available at CTAN}.
Development version(s) can be found \href{https://github.com/sasozivanovic/forest}{at GitHub}.
Comments, criticism, suggestions and code are all very welcome!  If you find the package useful, you
can show your appreciation by making a PayPal donation to \url{saso.zivanovic@guest.arnes.si}.


\section{Tutorial}
\label{sec:tutorial}

This short tutorial progresses from basic through useful to
obscure \dots

\subsection{Basic usage}
\label{tut:basic-usage}

A tree is input by enclosing its specification in a \index{forest}
environment.  The tree is encoded by \emph{the bracket syntax}:
every node is enclosed in square brackets; the children of a
node are given within its brackets, after its content.
{\lstdefinelanguage[my]{TeX}[LaTeX]{TeX}{keywords=forest,
  otherkeywords={[,]},keywordstyle=\pstyle,texcsstyle={}}%
\lstset{language={[my]TeX}}%
\begin{forestexample}
  \begin{forest}
    [VP
      [DP]
      [V'
        [V]
        [DP]
      ]
    ]
  \end{forest}
\end{forestexample}}
Binary trees are nice, but not the only thing this package can draw.
Note that by default, the children are vertically centered with
respect to their parent, i.e.\ the parent is vertically aligned with the midpoint between the
first and the last child.
\begin{forestexample}
  \begin{forest}
    [VP
      [DP[John]]
      [V'
        [V[sent]]
        [DP[Mary]]
        [DP[D[a]][NP[letter]]]
      ]
    ]
  \end{forest}
\end{forestexample}
Spaces around brackets are ignored --- format your code as you
desire!
\begin{forestexample}
  \begin{forest}
    [VP[DP][V'[V][DP]]]
  \end{forest}
  \quad
  \begin{forest}[VP
    [DP ] [ V'[V][ DP]]
    ]\end{forest}
\end{forestexample}
If you need a square bracket as part of a node's content, use
braces.  The same is true for the other characters which have a
special meaning in the \foRest; package, like comma
|,| and equality sign |=|.
\begin{forestexample}
  \begin{forest}
    [V{P,}
      [{[DP]}]
      [V'
        [V]
        [{===DP===}]]]
  \end{forest}
\end{forestexample}
Macros in a node specification will be expanded when the node is
drawn --- you can freely use formatting commands inside nodes!
\begin{forestexample}
  \begin{forest}
    [VP
      [{~\textbf~{DP}}]
      [V'
        [V]
        [DP]]]
  \end{forest}
\end{forestexample}

All the examples given above produced top-down trees with centered children.  The other sections
of this manual explain how various properties of a tree can be changed, making it possible to
typeset radically different-looking trees.  However, you don't have to learn everything about this
package to profit from its power.  Using styles, you can draw predefined types of trees with ease.
For example, a phonologist can use the \index{GP1} style from library \reflibrary{linguistics} to easily
typeset (Government Phonology) phonological representations.  The style is applied simply by
writing its name before the first (opening) bracket of the tree.
\begin{forestexample}[label=ex:gp1-frost,code prefix={\def\usepackage[##1]##2{}}]
  \usepackage[~linguistics~]{forest}
  \begin{forest} ~GP1~ [
    [O[x[f]][x[r]]]
    [R[N[x[o]]][x[s]]]
    [O[x[t]]]
    [R[N[x]]]
  ]\end{forest}
\end{forestexample}
Of course, someone needs to develop the style --- you, me, your local \TeX nician \dots\@
Fortunately, designing styles is not very difficult once you get the hang of \foRest;, if you
write one, please contribute!  Some macros relating to various fields are collected in
\emph{libraries} that are distributed alongside the main package.  This is the case for the
\index{GP1} style used above, which is defined in the |linguistics| library.  The simplest way to
load a library is as shown in the example, by loading the package with an optional argument.  For
more information on loading libraries, see \S\ref{ref:package-options}.


(Style \index{GP1} used above is defined in the \keyname{linguistics}
library of the \foRest; package.)

\subsection{Options}
\label{tut:options}

A node can be given various options, which control various
properties of the node and the tree.  For example, at the end of
section~\ref{tut:basic-usage}, we have seen that the \index{GP1} style
vertically aligns the parent with the first
child.  This is achieved by setting option \index{calign} (for
\emph{c}hild-\emph{align}ment) to \index{value=calign>first} (child).

Let's try.  Options are given inside the brackets, following the
content, but separated from it by a comma.  (If multiple options are
given, they are also separated by commas.)  A single option
assignment takes the form \meta{option name}|=|\meta{option value}.  (There are
also options which do not require a value or have a default value:
these are given simply as \meta{option name}.)
\begin{forestexample}[label=ex:numerals-simple,index={calign,value=calign>first}]
  \begin{forest}
    [\LaTeX\ numerals, ~calign=first~
      [arabic[1][2][3][4]]
      [roman[i][ii][iii][iv]]
      [alph[a][b][c][d]]
    ]
  \end{forest}
\end{forestexample}

The experiment has succeeded only partially.  The root node's
children are aligned as desired (so \index{calign}|=|\index{value=calign>first} applied to the
root node), but the value of the \index{calign} option didn't get
automatically assigned to the root's children! \emph{An option given
at some node applies only to that node.} In \foRest;, the options
are passed to the node's relatives via special keys, called
\emph{propagators}.  What we need above is the \index{for step=\index{tree}}
propagator.  Observe:

\begin{forestexample}[label=ex:numerals-manual]
  \begin{forest}
    [\LaTeX\ numerals,
         ~for tree~={calign=first}
      [arabic[1][2][3][4]]
      [roman[i][ii][iii][iv]]
      [alph[a][b][c][d]]
    ]
  \end{forest}
\end{forestexample}
The value of propagator \index{for step=\index{tree}} is the option string that we
want to process.  This option string is propagated to all the nodes in
the subtree\footnote{It might be more precise to call this option
\texttt{for subtree} \dots\@ but this name at least saves some typing.}
rooted in the current node (i.e.\ the node where \index{for step=\index{tree}} was
given), including the node itself.  (Propagator \index{for step=\index{descendants}} is
just like \index{for step=\index{tree}}, only that it excludes the node itself.  There
are many other \index{for step=\meta{step}} propagators; for the complete list, see
sections~\ref{ref:spatial-propagators} and \ref{ref:nodewalks}.)

Some other useful options are \index{option>parent anchor}, \index{option>child anchor} and
\index{tier}.  The \index{option>parent anchor} and \index{option>child anchor} options tell
where the parent's and child's endpoint of the edge between them should be, respectively: usually,
the value is either empty (meaning a smartly determined border point
\citep[see][\S16.11]{tikzpgf2.10}; this is the default) or a compass direction
\citep[see][\S16.5.1]{tikzpgf2.10}.  (Note: the \index{option>parent anchor} determines where the edge
from the child will arrive to this node, not where the node's edge to its parent will start!)

Option \index{tier} is what makes the
skeletal points $\times$ in example (\ref{ex:gp1-frost}) align horizontally although they
occur at different levels in the logical structure of the tree.
Using option \index{tier} is very simple: just set |tier=tier_name| at
all the nodes that you want to align horizontally.  Any tier name
will do, as long as the tier names of different tiers are
different \dots\@ (Yes, you can have multiple tiers!)
\begin{forestexample}[point={tier},index={option>parent anchor,option>child anchor,tier},label=ex:tier-manual]
  \begin{forest} 
    [VP, for tree={~parent anchor~=south, ~child anchor~=north}
      [DP[John,tier=word]]
      [V'
        [V[sent,tier=word]]
        [DP[Mary,tier=word]]
        [DP[D[a,tier=word]][NP[letter,tier=word]]]
      ]
    ]
  \end{forest}
\end{forestexample}
Before discussing the variety of \foRest;'s options, it is worth
mentioning that \foRest;'s node accepts all options \citep[see
\S16]{tikzpgf2.10} that \TikZ;'s node does --- mostly, it just passes
them on to \TikZ;.  For example, you can easily encircle a node like
this:\footnote{If option \texttt{draw} was not given, the shape of the node
would still be circular, but the edge would not be drawn.  For
details, see \cite[\S16]{tikzpgf2.10}.}
\begin{forestexample}
  \begin{forest}
    [VP,~circle~,~draw~
      [DP][V'[V][DP]]
    ]
  \end{forest}
\end{forestexample}

Let's have another look at example (\ref{ex:gp1-frost}).  You will note that the skeletal
positions were input by typing |x|s, while the result looks like
this: $\times$ (input as |\times| in math mode). Obviously, the
content of the node can be changed.  Even more, it can be
manipulated: added to, doubled, boldened, emphasized, etc.  We will
demonstrate this by making example (\ref{ex:numerals-manual}) a bit
fancier: we'll write the input in the arabic numbers and have
\LaTeX\ convert it to the other formats.  We'll start with the
easiest case of roman numerals: to get them, we can use the (plain)
\TeX\ command |\romannumeral|.  To change the content of the node,
we use option \index{content}.  When specifying its new value, we can use
|#1| to insert the current content.\footnote{This mechanism is called
\emph{wrapping}. \index{content} is the only option where wrapping works implicitely (simply
because I assume that wrapping will be almost exclusively used with this option).  To wrap values
of other options, use handler \index{wrap value}; see~\S\ref{ref:handlers}.}
\begin{forestexample}[point={content,delay},index={for step,step>children,content,delay},label=ex:romannumeral]
  \begin{forest}
    [roman, delay={for children={content=\romannumeral#1}}
      [1][2][3][4]
    ]
  \end{forest}
\end{forestexample}
This example introduces another option: \index{delay}.  Without it, the example wouldn't work: we
would get arabic numerals.  This is so because of the order in which the options are processed.
First, the processing proceeds through the tree in a depth-first, parent-first fashion (first the
parent is processed, and then its children, recursively; but see \index{processing order}).  Next,
the option string of a node is processed linearly, in the order they were given.  (Option
\index{content} is specified implicitely and is always the first.) If a propagator is encountered,
the options given as its value are propagated \emph{immediately}.  The net effect is that if the
above example contained simply |roman,for_children={content=...}|, the \index{content} option
given there would be processed \emph{before} the implicit content options given to the children
(i.e.\ numbers |1|, |2|, |3| and |4|).  Thus, there would be nothing for the |\romannumeral| to
change --- it would actually crash; more generally, the content assigned in such a way would get
overridden by the implicit content.  Key \index{delay} is true to its name.  It delays the
processing of the keylist given as its argument until the whole tree was processed.  In other words, it
introduces cyclical option processing.  Whatever is delayed in one cycle, gets processed in the next
one.  The number of cycles is not limited --- you can nest \index{delay}s as deep as you need.

Unlike \index{for step=\meta{step}} keys we have met before, \index{delay} is not a
spatial, but a temporal propagator.  Several other temporal propagators options exist, see
\S\ref{ref:stages}.

We are now ready to learn about simple conditionals.  Every node option has the corresponding
\index{if option=\meta{option}} and \index{where option=\meta{option}} keys.
\index{if option=\meta{option}}|=|\meta{value}\meta{true options}\meta{false options} checks whether
the value of \meta{option} equals \meta{value}.  If so, \meta{true options} are
processed, otherwise \meta{false options}.  The \index{where option=\meta{option}} keys are
the same, but do this for the every node in the subtree; informally
speaking, |where| = |for_tree| + |if|.  To see this in action,
consider the rewrite of the \index{tier} example (\ref{ex:tier-manual}) from above.  We don't set
the tiers manually, but rather put the terminal nodes (option
\index{n children} is a read-only option containing the number
of children) on tier \keyname{word}.\footnote{We could omit the braces around \texttt{0} because
it is a single character. If we were hunting for nodes with 42 children, we'd have to write 
\texttt{where n children=\{42\}...}.}
\begin{forestexample}[index={tier,where option,n children}]
  \begin{forest}
    ~where n children~=0{tier=word}{}
    [VP
      [DP[John]]
      [V'
        [V[sent]]
        [DP[Mary]]
        [DP[D[a]][NP[letter]]]
      ]
    ]
  \end{forest}
\end{forestexample}

Note that you usually don't want to embed a \index{where} conditional in a \index{for step=\index{tree}}, as this will lead to a multiple traversal of many nodes, resulting in a slower execution.
If you're inside a \index{for step=\index{tree}}, you probably want to use \index{if}.

Finally, let's talk about styles. Styles are simply collections of
options and/or other keys.  (They are not actually defined in the \foRest; package, but
rather inherited from |pgfkeys|.)  If you often want to have non-default 
parent/child anchors, say south/north as in example (\ref{ex:tier-manual}), you would save some
typing by defining a style.  Styles are defined using \PGF;'s handler 
|.style|, like shown below.\footnote{Style \index{sn edges} is actually already defined by library \reflibrary{linguistics}. The definition there is a bit more generic.}
\begin{forestexample}[index={tier,option>parent anchor,option>child anchor}]
  \begin{forest}
    ~sn edges~/~.style~={for tree={
            parent anchor=south, child anchor=north}},
    ~sn edges~
    [VP, 
      [DP[John,tier=word]]
      [V'
        [V[sent,tier=word]]
        [DP[Mary,tier=word]]
        [DP[D[a,tier=word]][NP[letter,tier=word]]]]]
  \end{forest}
\end{forestexample}
If you want to use a style in more than one tree, you have to define it outside the \index{forest}
environment.  Use macro \index{forestset} to do this.
\begin{lstlisting}
  ~\forestset~{
    sn edges/.style={for tree={parent anchor=south, child anchor=north}},
    background tree/.style={for tree={
                text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}}
  }
\end{lstlisting}

You might have noticed that in the last two examples contain, some keys occurred even before the
first opening bracket, contradicting was said at the beginning of this section.  This is mainly
just syntactic sugar (it can separate the design and the content): such \emph{preamble}
keys behave as if they were given in the root node, the only difference (which often does not
matter) being that they get processed before all other root node options, even the implicit
\index{content}.

If you find yourself writing the same preamble for every tree in your document,
consider redefining style \index{default preamble}, which is implicitely included at the beginning
of every preamble.  

\subsection{Decorating the tree}
\label{tut:decorating}

The tree can be decorated (think movement arrows) with arbitrary
\TikZ; code.
\begin{forestexample}
  \begin{forest}
    [XP
      [specifier]
      [X$'$
        [X$^0$]
        [complement]
      ]
    ]
    ~\node at (current bounding box.south)
      [below=1ex,draw,cloud,aspect=6,cloud puffs=30]
      {\emph{Figure 1: The X' template}};~
  \end{forest}
\end{forestexample}

However, decorating the tree would make little sense if one could
not refer to the nodes.  The simplest way to do so is to give them a
\TikZ; name using the \index{option>name} option, and then use this name in \TikZ;
code as any other (\TikZ;) node name.
\begin{forestexample}[point=name,index={option>phantom,option>name}]
  \begin{forest}
    [CP
      [DP,name=spec CP]
      [\dots
        [,phantom]
        [VP
          [DP]
          [V'
            [V]
            [DP,name=object]]]]]
    \draw[->,dotted] ~(object)~ to[out=south west,in=south] ~(spec CP)~;
  \end{forest}
\end{forestexample}

It gets better than this, however! In the previous examples, we put
the \TikZ; code after the tree specification, i.e.\ after the closing
bracket of the root node.  In fact, you can put \TikZ; code after
\emph{any} closing bracket, and \foRest; will know what the current
node is. (Putting the code after a node's bracket is actually just a
special way to provide a value for option \index{tikz} of that node.)  To
refer to the current node, simply use an empty node name.  This works both with and without
anchors \citep[see][\S16.11]{tikzpgf2.10}: below, |(.south east)| and |()|. 
\begin{forestexample}[index={option>phantom,option>name}]
  \begin{forest}
    [CP
      [DP,name=spec CP]
      [\dots
        [,phantom]
        [VP
          [DP]
          [V'
            [V]
            [DP,draw] ~{~
              \draw[->,dotted] ~()~ to[out=south west,in=south] (spec CP);
              \draw[<-,red] ~(.south east)~--++(0em,-4ex)--++(-2em,0pt)
                   node[anchor=east,align=center]{This guy\\has moved!};
                 ~}~
          ]]]]
  \end{forest}
\end{forestexample}

Important: \emph{the \TikZ; code should usually be enclosed in braces} to hide
it from the bracket parser.  You don't want all the bracketed code
(e.g.\ |[->,dotted]|) to become tree nodes, right? (Well, they
probably wouldn't anyway, because \TeX\ would spit out a thousand
errors.)

\bigskip

Finally, the most powerful tool in the node reference toolbox:
\emph{relative nodes}.  It is possible to refer to other nodes which stand
in some (most often geometrical) relation to the current node.  To
do this, follow the node's name with a \index>{!} and a \emph{node walk}
specification.

A node walk is a concise\footnote{Actually, \foRest; distinguishes two kinds of steps in node walks:
  long-form and short-form steps.  This section introduces only short-form steps.  See
  \S\ref{ref:nodewalks}.} way of expressing node relations.  It is simply a string of steps, which
are represented by single characters, where: \index{ss u} stands for the parent node (up); \index{ss
  p} for the previous sibling; \index{ss n} for the next sibling; \index{ss s} for \emph{the}
sibling (useful only in binary trees); \index{ss 1}, \index{ss 2}, \index[not print]{ss 3,ss 4,ss
  5,ss 6,ss 7,ss 8}\dots\ \index{ss 9} for first, second, \dots\ ninth child; \index{ss l}, for the
last child, etc.  For the complete specification, see section~\ref{ref:short-form-steps}.

To see the nodewalk in action, consider the following examples.
In the first example, the agree arrow connects the V node, specified
simply as |()|, since the \TikZ; code follows |[V]|, and the DP node,
which is described as ``a sister of V's parent'': |!us| = up +
sibling. 
\begin{forestexample}[index>={!}]
  \begin{forest}
    [VP
      [DP] 
      [V'
        [V] {\draw[<->] ~()~
             .. controls +(left:1cm) and +(south west:0.4cm) ..
             node[very near start,below,sloped]{\tiny agree}
             ~(!us)~;}
        [DP]
      ]
    ]
  \end{forest}
\end{forestexample}

{\footnotesize\begin{forestexample}[index={option>phantom,tikz,fit to,tree},layout=export,basicstyle=\footnotesize\ttfamily]
  \begin{forest}
    [CP
      [DP$_1$]
      [\dots
        [,phantom]
        [VP,tikz={\node [draw,red,inner sep=0,~fit to~=tree]{};}
          [DP$_2$] 
          [V'
            [V]
            [DP$_3$]
    ]]]]
  \end{forest}
\end{forestexample}}
The second example uses \TikZ;'s fitting library to compute the
smallest rectangle containing node VP, its first child (DP$_2$) and its last grandchild (DP$_3$).
The example also illustrates that the \TikZ; code 
can be specified via the ``normal'' option syntax, i.e.\ as a value
to option \index{tikz}.\footnote{\label{fn:fit-to-tree}Actually, there's a simpler way to do this: use \index{fit to}\keyname{=}\index{tree}!\forestexampleimport}
\begin{forestexample}[point=tikz,index={option>phantom,tikz},index>={!}]
  \begin{forest}
    [CP
      [DP$_1$]
      [\dots
        [,phantom]
        [VP,tikz={\node [draw,red,fit=~()(!1)(!ll)~] {};}
          [DP$_2$] 
          [V'
            [V]
            [DP$_3$]
    ]]]]
  \end{forest}
\end{forestexample}


\subsection{Node positioning}
\label{tut:node-positioning}

\FoRest; positions the nodes by a recursive bottom-up algorithm which, for every non-terminal node,
computes the positions of the node's children relative to their parent.  By default, all the
children will be aligned horizontally some distance down from their parent: the ``normal'' tree
grows down.  More generally, however, the direction of growth can change from node to node; this is
controlled by option \index{grow}=\meta{direction}.\footnote{The direction can be specified either in
  degrees (following the standard mathematical convention that $0$ degrees is to the right, and that
  degrees increase counter-clockwise) or by the compass directions: \texttt{east}, \texttt{north east},
  \texttt{north}, etc.}  The system thus computes and stores the positions of children using a
coordinate system dependent on the parent, called an \emph{ls-coordinate system}: the origin is the
parent's anchor; l-axis is in the direction of growth in the parent; s-axis is orthogonal to the
l-axis (positive side in the counter-clockwise direction from $l$-axis); l stands for \emph{l}evel,
s for \emph{s}ibling.  The example shows the ls-coordinate system for a node with |grow=45|.

\begin{forestexample}[point=grow,index=grow]
  \begin{forest} background tree
    [parent, grow=45
      [child 1][child 2][child 3][child 4][child 5]
    ]
    \draw[,->](-135:1cm)--(45:3cm) node[below]{$l$};
    \draw[,->](-45:1cm)--(135:3cm) node[right]{$s$};
  \end{forest}
\end{forestexample}

\begin{forestexample}[basicstyle=\scriptsize\ttfamily,layout=export]
  \newcommand\measurexdistance[5][####1]{\measurexorydistance{#2}{#3}{#4}{#5}{\x}{-|}{(5pt,0)}{#1}}
  \newcommand\measureydistance[5][####1]{\measurexorydistance{#2}{#3}{#4}{#5}{\y}{|-}{(0,5pt)}{#1}}
  \tikzset{dimension/.style={<->,>=latex,thin,every rectangle node/.style={midway,font=\scriptsize}},
    guideline/.style=dotted}
  \newdimen\absmd
  \def\measurexorydistance#1#2#3#4#5#6#7#8{%
    \path #1 #3 #6 coordinate(md1) #1; \draw[guideline] #1 --  (md1);
    \path (md1) #6 coordinate(md2) #2; \draw[guideline] #2 -- (md2);
    \path let \p1=($(md1)-(md2)$), \n1={abs(#51)} in \pgfextra{\xdef\md{#51}\global\absmd=\n1\relax};
    \def\distancelabelwrapper##1{#8}%
    \ifdim\absmd>5mm
      \draw[dimension] (md1)--(md2) node[#4]{\distancelabelwrapper{\uselengthunit{mm}\rndprintlength\absmd}};
    \else
      \ifdim\md>0pt
        \draw[dimension,<-] (md1)--+#7; \draw[dimension,<-] let \p1=($(0,0)-#7$) in (md2)--+(\p1);
      \else
        \draw[dimension,<-] let \p1=($(0,0)-#7$) in (md1)--+(\p1); \draw[dimension,<-] (md2)--+#7;
      \fi
      \draw[dimension,-] (md1)--(md2) node[#4]{\distancelabelwrapper{\uselengthunit{mm}\rndprintlength\absmd}};
    \fi}
\end{forestexample}
\input{\jobname.tmp}


The l-coordinate of children is (almost) completely under your control, i.e.\ you set what is
often called the level distance by yourself.  Simply set option \index{option>l} to change the
distance of a node from its parent.  More precisely, \index{option>l}, and the related option
\index{option>s}, control the distance between the (node) anchors of a node and its parent.  The
anchor of a node can be changed using option \index{option>anchor}: by default, nodes are anchored at
their base; see \cite[\S16.5.1]{tikzpgf2.10}.)  In the example below, positions of the anchors are
shown by dots: observe that anchors of nodes with the same \index{option>l} are aligned and that the
distances between the anchors of the children and the parent are as specified in the
code.\footnote{Here are the definitons of the macros for measuring distances.  Args: the x or y
distance between points \#2 and \#3 is measured; \#4 is where the distance line starts (given as an
absolute coordinate or an offset to \#2); \#5 are node options; the optional arg \#1 is the format of
label. (Lengths are printed using package \texttt{printlen}.)

\box\codebox}
\begin{forestexample}[layout=tree on top,index={for step,tree,tikz,option>l,option>anchor},index>={!}]
  \begin{forest} background tree,
    for tree={draw,tikz={\fill[](.anchor)circle[radius=1pt];}}
    [parent
      [child 1, ~l~=10mm, ~anchor~=north west]
      [child 2, ~l~=10mm, ~anchor~=south west]
      [child 3, ~l~=12mm, ~anchor~=south]
      [child 4, ~l~=12mm, ~anchor~=base east]
    ]
    \measureydistance[\texttt{l(child)}=#1]{(!2.anchor)}{(.anchor)}{(!1.anchor)+(-5mm,0)}{left}
    \measureydistance[\texttt{l(child)}=#1]{(!3.anchor)}{(.anchor)}{(!4.anchor)+(5mm,0)}{right}
    \measurexdistance[\texttt{s sep(parent)}=#1]{(!1.south east)}{(!2.south west)}{+(0,-5mm)}{below}
    \measurexdistance[\texttt{s sep(parent)}=#1]{(!2.south east)}{(!3.south west)}{+(0,-5mm)}{below}
    \measurexdistance[\texttt{s sep(parent)}=#1]{(!3.south east)}{(!4.south west)}{+(0,-8mm)}{below}
  \end{forest}
\end{forestexample}

Positioning the chilren in the s-dimension is the job and \emph{raison d'etre} of the package.  As a
first approximation: the children are positioned so that the distance between them is at least the
value of option \index{s sep} (s-separation), which defaults to double \PGF;'s |inner_xsep| (and this
is 0.3333em by default).  As you can see from the example above, s-separation is the distance
between the borders of the nodes, not their anchors!

A fuller story is that \index{s sep} does not control the s-distance between two siblings, but rather
the distance between the subtrees rooted in the siblings.  When the green and the yellow child of
the white node are s-positioned in the example below, the horizontal
distance between the green and the yellow subtree is computed.  It can be seen with the naked eye
that the closest nodes of the subtrees are the TP and the DP with a red border.  Thus, the children
of the root CP (top green DP and top yellow TP) are positioned so that the horizontal distance
between the red-bordered TP and DP equals \index{s sep}.
\begin{forestexample}[index={for step,tree,s sep}]
  \begin{forest}
    important/.style={name=#1,draw={red,thick}}
    [CP, ~s sep~=3mm, for tree=draw
      [DP, for tree={fill=green}
        [D][NP[N][CP[C][TP,important=left
        [T][vP[v][VP[DP][V'[V][DP]]]]]]]]
      [TP,for tree={fill=yellow}
        [T][vP[v][VP[DP,important=right][V'[V][DP]]]]]
    ]
    \measurexdistance[\texttt{s sep(root)}=#1]
      {(left.north east)}{(right.north west)}{(.north)+(0,3mm)}{above}
  \end{forest}
\end{forestexample}

Note that \foRest; computes the same distances between nodes
regardless of whether the nodes are filled or not, or whether their
border is drawn or not.  Filling the node or drawing its border does
not change its size.  You can change the size by adjusting \TikZ;'s
|inner_sep| and |outer_sep| \citep[\S16.2.2]{tikzpgf2.10}, as shown
below:
\begin{forestexample}[index={for step,tree,s sep}]
  \begin{forest}
    important/.style={name=#1,draw={red,thick}}
    [CP, s sep=3mm, for tree=draw
      [DP, for tree={fill=green,~inner sep~=0}
        [D][NP,important=left[N][CP[C][TP[T][vP[v]
        [VP[DP][V'[V][DP]]]]]]]]
      [TP,for tree={fill=yellow,~outer sep~=2pt}
        [T,important=right][vP[v][VP[DP][V'[V][DP]]]]]
    ]
    \measurexdistance[\texttt{s sep(root)}=#1]
      {(left.north east)}{(right.north west)}{(.north)+(0,3mm)}{above}
  \end{forest}
\end{forestexample}
(This looks ugly!) Observe that having increased |outer sep| makes the edges stop touching
borders of the nodes. By (\PGF;'s) default, the |outer sep| is exactly half of the border
line width, so that the edges start and finish precisely at the border.

Let's play a bit and change the \index{option>l} of the root of the yellow subtree.  Below, we set the
vertical 
distance of the yellow TP to its parent to 3\,cm: and the yellow submarine sinks diagonally \dots\@
Now, the closest nodes are the higher yellow DP and the green VP.
\begin{forestexample}[index={option>l,s sep,for step,tree}]
  \begin{forest}
    important/.style={name=#1,draw={red,thick}}
    [CP, s sep=3mm, for tree=draw
      [DP, for tree={fill=green}
        [D][NP[N][CP[C][TP
        [T][vP[v][VP,important=left[DP][V'[V][DP]]]]]]]]
      [TP,for tree={fill=yellow}, l=3cm
        [T][vP[v][VP[DP,important=right][V'[V][DP]]]]]
    ]
    \measurexdistance[\texttt{s sep(root)}=#1]
      {(left.north east)}{(right.north west)}{(.north)+(0,3mm)}{above}
  \end{forest}
\end{forestexample}

Note that the yellow and green nodes are not vertically aligned anymore.  The positioning algorithm
has no problem with that.  But you, as a user, might have, so here's a neat trick.  (This only works
in the ``normal'' circumstances, which are easier to see than describe.)
\begin{forestexample}[label=ex:l*,index={dimen*=l,option>phantom,for step,tree}]
  \begin{forest}
    [CP, for tree=draw
      [DP, for tree={fill=green},~l*~=3
        [D][NP]]
      [TP,for tree={fill=yellow}
        [T][VP[DP][V'[V][DP]]]]
    ]
  \end{forest}
\end{forestexample}
We have changed DP's \index{option>l}'s value via ``augmented assignment'' known from
many programming languages: above, we have used |l*=3| to triple
\index{option>l}'s value; we could have also said |l+=5mm| or |l-=5mm| to
increase or decrease its value by 5\,mm, respectively.  This
mechanism works for every numeric and dimensional option in \foRest;.

Let's now play with option \index{s sep}.
\begin{forestexample}[index={s sep,option>l,dimen*=l,for step,tree}]
  \begin{forest}
    [CP, for tree=draw, ~s sep~=0
      [DP, for tree={fill=green},l*=3
        [D][NP]]
      [TP,for tree={fill=yellow}
        [T][VP[DP][V'[V][DP]]]]
    ]
  \end{forest}
\end{forestexample}
Surprised? You shouldn't be. The value of \index{s sep} at a given node controls the s-distance
\emph{between the subtrees rooted in the children of that node}!  It has no influence over the
internal geometry of these subtrees. In the above example, we have set |s_sep=0| only for the root
node, so the green and the yellow subtree are touching, although internally, their nodes are not.
Let's play a bit more.  In the following example, we set the \index{s sep} to: $0$ at the last
branching level (level 3; the root is level 0), to 2\,mm at level 2, to 4\,mm at level 1 and to
6\,mm at level 0.

\begin{forestexample}[label=ex:spread-s,point={level},index={option>level,for step,tree,s sep},index>={!}]
  \begin{forest}
    for tree={~s sep~=(3-level)*2mm}
    [CP, for tree=draw
      [DP, for tree={fill=green},l*=3
        [D][NP]]
      [TP,for tree={fill=yellow}
        [T][VP[DP][V'[V][DP]]]]
    ]
    \measurexdistance{(!11.south east)}{(!12.south west)}{+(0,-5mm)}{below}
    \path(md2)-|coordinate(md)(!221.south east);
    \measurexdistance{(!221.south east)}{(!222.south west)}{(md)}{below}
    \measurexdistance{(!21.north east)}{(!22.north west)}{+(0,2cm)}{above}
    \measurexdistance{(!1.north east)}{(!221.north west)}{+(0,-2.4cm)}{below}
  \end{forest}
\end{forestexample}
As we go up the tree, the nodes ``spread.'' At the lowest level, V and DP are touching.  In the
third level, the \index{s sep} of level 2 applies, so DP and V' are 2\,mm apart.  At the second
level we 
have two pairs of nodes, D and NP, and T and TP: they are 4\,mm apart.  Finally, at level 1, the
\index{s sep} of level 0 applies, so the green and yellow DP are 6\,mm apart.  (Note that D and NP are
at level 2, not 4! Level is a matter of structure, not geometry.)

As you have probably noticed, this example also demostrated that we can compute the value of an
option using an (arbitrarily complex) formula.  This is thanks to \PGF;'s module |pgfmath|.
\FoRest; provides an interface to |pgfmath| by defining |pgfmath| functions for every node option,
and some other information, like the \index{option>level} we have used above, the number of children
\index{n children}, the sequential number of the child \index{option>n}, etc.  For details, see
\S\ref{ref:pgfmath}. 

The final separation parameter is \index{l sep}.  It determines the minimal
separation of a 
node from its descendants.  It the value of \index{option>l} is too small, then \emph{all} the
children (and thus their subtrees)
are pushed 
away from the parent (by increasing their \index{option>l}s), so that the distance between the node's
and each child's subtree
boundary is at least \index{l sep}.  The initial \index{option>l} can be too small for
two reasons: either 
some child is too high, or the parent is too deep.  The first problem is easier to see: we force the
situation using a bottom-aligned multiline node.  (Multiline nodes can be easily created using |\\|
as a line-separator.  However, you must first specify the horizontal alignment using option
\index{align} (see \S\ref{ref:node-appearance}). 
Bottom vertical alignment is achieved by setting \index{base}|=|\index{value=base>bottom};
the default, unlike in \TikZ;, is \index{base}|=|\index{value=base>top}). 
\begin{forestexample}[point={align,base},index={align,base}]
  \begin{forest}
    [parent
      [child]
      [child]
      [a very\\tall\\child, align=center, base=bottom]
    ]
  \end{forest}
\end{forestexample}

The defaults for \index{option>l} and \index{l sep} are set so that they ``cooperate.''
What this 
means and why it is necessary is a complex issue explained in \S\ref{tut:defaults}, which you will
hopefully never have to read \dots\@ You might be out of luck, however.  What if you 
needed to decrease the level distance? And nothing happened, like below on the left?  Or, what if
you used lots of parenthesis in your nodes?  And got a strange vertical misalignment, like below
on the right?  Then rest assured that these (at least) are features not bugs and read
\S\ref{tut:defaults}.
\begin{forestexample}[layout=tree on top,v sep=-55ex,code left skip=-3cm,label=ex:misalignments,index={option>phantom,for step,step>children,fit,propagator>for,baseline,edge,descendants,content,pgfmath,ss 1}]
  \begin{forest}
    [,phantom,for children={l sep=1ex,fit=band,
      for 1={edge'=,l=0},baseline}
      [{l+=5mm},for descendants/.pgfmath=content
        [AdjP[AdvP][Adj'[Adj][PP]]]]
      [default
        [AdjP[AdvP][Adj'[Adj][PP]]]]
      [{l-=5mm},for descendants/.pgfmath=content
        [AdjP[AdvP][Adj'[Adj][PP]]]]
    ]
    \path (current bounding box.west)|-coordinate(l1)(!212.base);
    \path (current bounding box.west)|-coordinate(l2)(!2121.base);
    \path (current bounding box.east)|-coordinate(r1)(!212.base);
    \path (current bounding box.east)|-coordinate(r2)(!2121.base);
    \draw[dotted] (l1)--(r1) (l2)--(r2);
  \end{forest}
  \hspace{5cm}
  \begin{forest}
    [x forest, baseline
      [x[x[x[x[x[x[x[x[x[x[x[x[x]]]]]]]]]]]]]
      [(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)]]]]]]]]]]]]]
    ]
  \end{forest}
\end{forestexample}

\subsubsection{The defaults, or the hairy details of vertical alignment}
\label{tut:defaults}

In this section we discuss the default values of options controlling the l-alignment of the nodes.
The defaults are set with top-down trees in mind, so l-alignment is actually vertical alignment.
There are two desired effects of the defaults.  First, the spacing between the nodes of a tree
should adjust to the current font size.  Second, the nodes of a given level should be vertically
aligned (at the base), if possible.

Let us start with the base alignment: \TikZ;'s default is to anchor the nodes at their center,
while \foRest;, given the usual content of nodes in linguistic representations, rather anchors them
at the base \cite[\S16.5.1]{tikzpgf2.10}.  The difference is particularly clear for a ``phonological''
representation:
\begin{forestexample}[index={for step,tree,option>anchor}]
  \begin{forest} for tree={anchor=center}
    [maybe[m][a][y][b][e]]
  \end{forest}\quad
  \begin{forest}
    [maybe[m][a][y][b][e]]
  \end{forest}
\end{forestexample}
The following example shows that the vertical distance between nodes depends on the current font size.
\begin{forestexample}
  \hbox{\small A small tree
  \begin{forest} baseline
    [VP[DP][V'[V][DP]]]
  \end{forest}
  \normalsize and
  \large
  a large tree
  \begin{forest} baseline
    [VP[DP][V'[V][DP]]]
  \end{forest}}
\end{forestexample}
Furthermore, the distance between nodes also depends on the value of \PGF;'s |inner_sep| (which
also depends on the font size by default: it equals 0.3333\,em).
\[\index{l sep}=\mbox{height}(\mbox{strut})+\mbox{\texttt{inner ysep}}\]
The default value of \index{s sep} depends on |inner_xsep|: more precisely, it equals double
|inner_xsep|). 
\begin{forestexample}[index={baseline,for step,tree}]
  \begin{forest} baseline,for tree=draw
    [VP[DP][V'[V][DP]]]
  \end{forest}    
  \pgfkeys{/pgf/inner sep=0.6666em}
  \begin{forest} baseline,for tree=draw
    [VP[DP][V'[V][DP]]]
  \end{forest}    
\end{forestexample}
Now a hairy detail: the formula for the default \index{option>l}.
\[\index{option>l}=\index{l sep}+2\cdot\mbox{\texttt{outer ysep}}+\mbox{total
height}(\mbox{`dj'})\]

To understand what this is all about we must first explain why it is necessary to set the default
\index{option>l} at all?  Wouldn't it be enough to simply set \index{l sep} (leaving
\index{option>l} at 0)?
The problem is that not all letters have the same height and depth.  A tree where the vertical
position of the nodes would be controlled solely by (a constant) \index{l sep} could
result in a ragged tree (although the height of the child--parent edges would be constant).
\begin{forestexample}[index={baseline,for step,step>children,no edge,option>name,descendants,option>l}]
  \begin{forest}
    [default,baseline,for children={no edge}
      [DP
        [AdjP[Adj]]
        [D'[D][NP,name=np]]]]
    \path (current bounding box.west)|-coordinate(l)(np.base);
    \path (current bounding box.east)|-coordinate(r)(np.base);
    \draw[dotted] (l)--(r);
  \end{forest}
  \begin{forest}
    [{l=0},baseline,for children={no edge}    
      [DP,for descendants={l=0}
        [AdjP[Adj]]
        [D'[D][NP,name=np]]]]
    \path (current bounding box.west)|-coordinate(l)(np.base);
    \path (current bounding box.east)|-coordinate(r)(np.base);
    \draw[dotted] (l)--(r);
  \end{forest}
\end{forestexample}
The vertical misalignment of Adj in the right tree is a consequence of the fact that letter j is the
only letter with non-zero depth in the tree.  Since only \index{l sep} (which is constant
throughout the tree) controls the vertical positioning, Adj, child of Ad\emph{j}P, is pushed lower
than the other nodes on level 2.  If the content of the nodes is variable enough (various heights
and depths), the cumulative effect can be quite strong, see the right tree of example
(\ref{ex:misalignments}).

Setting only a default \index{l sep} thus does not work well enough in general.  The same
is true for the reverse possibility, setting a default \index{option>l} (and leaving \index{l sep} at 0).  In the example below, the depth of the multiline node (anchored at the top
line) is such that the child--parent edges are just too short if the level distance is kept constant.
Sometimes, misalignment is much preferred \dots
\begin{forestexample}[index={align,{value=align>center},for step,tree,l sep}]
  \mbox{}\begin{forest}
    [default
      [first child[a][b][c]]
      [second child\\[-1ex]\scriptsize(a copy),
       align=center[a][b][c]]
    ]
  \end{forest}\\
  \begin{forest} for tree={l sep=0}
    [{\texttt{l sep}=0}
      [first child[a][b][c]]
      [second child\\[-1ex]\scriptsize(a copy),
                   align=center[a][b][c]]
    ]
  \end{forest}
\end{forestexample}

Thus, the idea is to make \index{option>l} and \index{l sep} work as a team:
\index{option>l} prevents 
misalignments, if possible, while \index{l sep} determines the minimal vertical distance
between levels.  Each of the two options deals with a certain kind of a ``deviant'' node, i.e.\ a
node which is too high or too deep, or a node which is not high or deep enough, so we need to
postulate what a \emph{standard} node is, and synchronize them so that their effect on standard
nodes is the same.

By default, \foRest; sets the standard node to be a node containing letters d and j.  Linguistic
representations consist mainly of letters, and in the \TeX's default Computer Modern font, d is the
highest letter (not character!), and j the deepest, so this decision guarantees that trees
containing only letters will look nice.  If the tree contains many parentheses, like the right
tree of example (\ref{ex:misalignments}), the default will of course fail
and the standard node needs to be modified.  But for many applications, including nodes with
indices, the default works.

The standard node can be changed using macro \index{forestStandardNode};
see \ref{ref:standard-node}. 

\subsection{Advanced option setting}
\label{tut:advanced-option-setting}

We have already seen that the value of options can be manipulated: in (\ref{ex:romannumeral}) we have
converted numeric content from arabic into roman numerals using the \emph{wrapping} mechanism
|content=\romannumeral#1|; in (\ref{ex:l*}), we have tripled the value of |l|
by saying |l*=3|.  In this section, we will learn about the mechanisms for setting and
referring to option values offered by \foRest;.

One other way to access an option value is using macro \index{forestoption}.  The macro takes a
single argument: an option name.  (For details, see \S\ref{sec:option-reading}.)  In the
following example, the node's child sequence number is appended to the existing content. (This is
therefore also an example of wrapping.)
\begin{forestexample}[label=ex:forestoption,index={option>phantom,delay,for step,descendants,content,option>n,forestoption}]
  \begin{forest}
    [,phantom,delay={for descendants={
      content=#1$_{~\forestoption~{n}}$}}
    [c][o][u][n][t]]
  \end{forest}
\end{forestexample}

However, only options of the current node can be accessed using \index{forestoption}.  To
access option values of other nodes, \foRest;'s extensions to the \PGF;'s mathematical library
|pgfmath|, documented in \citep[part VI]{tikzpgf2.10}, must be used.  To see |pgfmath| in action,
first take a look at the crazy tree on the title page, and observe how the nodes are
rotated: the value given to (\TikZ;) option \texttt{rotate} is a full-fledged |pgfmath| expression
yielding an integer
in the range from $-30$ to $30$.  Similiarly, \index{dimen+=l} adds a random float
in the $[-5,5]$ range to the current value of \index{option>l}.

Example (\ref{ex:spread-s}) demonstrated that information about
the node, like the node's level, can be accessed within |pgfmath| expressions.  All
options are accessible in this way, i.e.\ every option has a corresponding |pgfmath| function.
For example, we could rotate the node based on its content:
\begin{forestexample}[index={delay,for step,tree,content}]
  \begin{forest}
    delay={for tree={~rotate=content~}}
    [30[-10[5][0]][-90[180]][90[-60][90]]]
  \end{forest}
\end{forestexample}

All numeric, dimensional and boolean options of \foRest; automatically pass the given value
through |pgfmath|.  If you need pass the value through |pgfmath| 
for a string option, use the \index{pgfmath} handler.  The following example sets the node's
content to its child sequence number (the root has child sequence number 0).
\begin{forestexample}[index={delay,for step,tree,content,option>n,pgfmath}]
  \begin{forest}
    delay={for tree={content/~.pgfmath~=int(n)}}
    [[[][][]][[][]]]
  \end{forest}
\end{forestexample}

As mentioned above, using |pgfmath| it is possible to access options of non-current nodes.  This
is achieved by providing the option function with a \index{relative node name}
(see~\S\ref{ref:relative-node-names}) argument.\footnote{The form without
parentheses \texttt{option\string_name} that we have been using until now to refer to an option of
the 
current node is just a short-hand notation for \texttt{option\string_name()} --- note that in some
contexts, like preceding \texttt{+} or \texttt{-}, the short form does not work! (The same
seems to be true for all pgfmath functions with ``optional'' arguments.)}  In the next example, we
rotate the node based on the content of its parent.
\begin{forestexample}[index={delay,for step,descendants,content,ss u},index>={!}]
  \begin{forest}
    delay={for descendants={rotate=content~("!u")~}}
    [30[-10[5][0]][-90[180]][90[-60][90]]]
  \end{forest}
\end{forestexample}
Note that the argument of the option function is surrounded by double quotation marks: this is
to prevent evaluation of the relative node name as a |pgfmath| function --- which it is not.

Handlers \index{wrap pgfmath arg} and \index{wrap $n$ pgfmath args}
(for $n=2,\dots,8$) combine the wrapping mechanism with the |pgfmath| evaluation.  The
idea is to compute (most often, just access option values) arguments using |pgfmath| and then
wrap them with the given macro.  Below, this is used to include the number of parent's children in
the index. 
\begin{forestexample}[index={option>phantom,delay,for step,descendants,content,option>n,n children,wrap $n$ pgfmath args},index>={!}]
  \begin{forest} [,phantom,delay={for descendants={
              ~content/.wrap 3 pgfmath args=
              {#1$_{#2/#3}$}{content}{n}{n_children("!u")}~}}
    [c][o][u][n][t]]
  \end{forest}
\end{forestexample}
Note the underscore |__| character in |n__children|: in |pgfmath| function names, spaces,
apostrophes and other non-alphanumeric characters from option names are all replaced by
underscores. 

As another example, let's make the numerals example (\ref{ex:numerals-simple}) a bit fancier.
The numeral type is read off the parent's content and used to construct the appropriate control
sequence (|\@arabic|, |\@roman| and |\@alph|).  (Also, the numbers are not specified in content
anymore: we simply read the sequence number \index{option>n}.  And, to save some horizontal space for the
code, each child of the root is pushed further down.)
\begin{forestexample}[index={delay,where option,option>level,content,option>n,for step,step>children,option>l,wrap $n$ pgfmath args},index>={!}]
  \begin{forest}
    delay={where level={2}{~content/.wrap 2 pgfmath args=
        {\csname @#1\endcsname{#2}}{content("!u")}{n}~}{}},
    for children={l*=n},
    [\LaTeX numerals,
      [arabic[][][][]]
      [roman[][][][]]
      [alph[][][][]]
    ]
  \end{forest}
\end{forestexample}

The final way to use |pgfmath| expressions in \foRest;: |if| clauses.  In
section~\ref{tut:options}, we have seen that every option has a corresponding \index{if option=\meta{option}}
(and \index{where option=\meta{option}} key.  However, these are just a matter of convenience.  The full
power resides 
in the general \index{conditional>if} conditional, which takes three arguments: 
|if=|\meta{condition}\meta{true options}\meta{false options}, where \meta{condition} can be any
|pgfmath| expression 
(non-zero means true, zero means false).  (Once again, propagator \index{propagator>where} is an abbreviation
for \index{for step=\index{tree}}|={|\index{conditional>if}|=...}|.)  In the following example, \index{conditional>if} option
is used to orient the 
arrows from the smaller number to the greater, and to color the odd and even numbers differently.

\forestset{random tree/.style n args={3}{% #1=max levels, #2=max children, #3=max content
      content/.pgfmath={random(0,#3)},
      if={#1>0}{repeat={random(0,#2)}{append={[,random tree={#1-1}{#2}{#3}]}}}{}}}
\begin{forestexample}[index={before typesetting nodes,for step,descendants,conditional>if,content,edge,edge label,tree},index>={!},point=if]
  \pgfmathsetseed{314159}
  \begin{forest}
    before typesetting nodes={
      for descendants={
        if={content()>content("!u")}{edge=->}{
          if={content()<content("!u")}{edge=<-}{}},
        edge label/.wrap pgfmath arg=
          {node[midway,above,sloped,font=\scriptsize]{+#1}}
          {int(abs(content()-content("!u")))}
      },
      for tree={circle,if={mod(content(),2)==0}
                          {fill=yellow}{fill=green}}
    }
    [,random tree={3}{3}{100}]
  \end{forest}
\end{forestexample}

This exhausts the ways of using |pgfmath| in forest.  We continue by introducing \emph{relative
node setting}: write \index{relative node name}|.|\meta{option}|=|\meta{value} to set the
value of \meta{option} of the specified relative node. Important: computation (pgfmath or wrap) of
the value is 
done in the context of the original node.  The following example defines style \keyname{move} which
not only draws an arrow from the source to the target, but also moves the content of the source
to the target (leaving a trace).  Note the difference between |#1| and |##1|: |#1| is the argument
of the style \keyname{move}, i.e.\ the given node walk, while |##1| is the original option value
(in this case, content).
\begin{forestexample}[index={for step,tree,calign,tikz,delay,content},index>={!}]
  \begin{forest}
    for tree={calign=fixed edge angles},
    move/.style={
      tikz={\draw[->] () to[out=south west,in=south] (#1);},
      delay={~#1.content~={##1},content=$t$}},
    [CP[][C'[C][\dots[,phantom][VP[DP][V'[V][DP,move=!r1]]]]]]
  \end{forest}
\end{forestexample}

In the following example, the content of the branching nodes is computed by \foRest;: a branching
node is a sum of its 
children.  Besides the use of the relative node setting, this example notably uses a recursive
style: for each child of the node, style \keyname{calc} first applies itself to the child and then
adds the result to the node; obviously, recursion is made to stop at terminal nodes. 
\begin{forestexample}[index={if option,n children,content,for step,step>children,delay,pgfmath},index>={!}]
  \begin{forest}
    calc/.style={if n children={0}{}{content=0,for children={
          calc,~!u.content~/.pgfmath=int(content("!u")+content())}}},
    delay=calc,
    [[[3][4][5]][[3][9]][8][[[1][2][3]]]]
  \end{forest}
\end{forestexample}


\subsection{Externalization}
\label{tut:externalization}

\FoRest; can be quite slow, due to the slowness of both \PGF;/\TikZ; and its own computations.
However, using \emph{externalization}, the amount of time spent in \foRest; in everyday life can
be reduced dramatically.  The idea is to typeset the trees only once, saving them in separate
PDFs, and then, on the subsequent compilations of the document, simply include these PDFs instead
of doing the lenghty tree-typesetting all over again.

\FoRest;'s externalization mechanism is built on top of \TikZ;'s |external| library.  It
enhances it by automatically detecting the code and context changes: the tree is recompiled if and
only if either the code in the \index{forest} environment or the context (arbitrary parameters; by
default, the parameters of the standard node) changes.

To use \foRest;'s externalization facilities, say:\footnote{When you switch on
the externalization for a document containing many \keyname{forest} environments, the first
compilation can take quite a while, much more than the compilation without externalization. (For
example, more than ten minutes for the document you are reading!)  Subsequent compilations,
however, will be very fast.}\index[not print]{external}
\begin{lstlisting}[point=external]
  \usepackage[external]{forest}
  ~\tikzexternalize~
\end{lstlisting}

If your \index{forest} environment contains some macro, you will probably want the externalized
tree to be recompiled when the definition of the macro changes.  To achieve this, use
\index{forestset}|{|\index{external/depends on macro}|=|\cmdname{macro}|}|.  The effect is
local to the \TeX\ group.

\TikZ;'s externalization library promises a |\label| inside the externalized graphics to work
out-of-box, while |\ref| inside the externalized graphics should work only if the externalization
is run manually or by |make| \citep[\S32.4.1]{tikzpgf2.10}.  A bit surprisingly perhaps, the
situation is roughly reversed in \foRest;.  |\ref| inside the externalized graphics will work
out-of-box.  |\label| inside the externalized graphics will not work at all.  Sorry.  (The reason
is that \foRest; prepares the node content in advance, before merging it in the whole tree, which
is when \TikZ;'s externalization is used.)

\subsection{Expansion control in the bracket parser}
\label{tut:bracket}

By default, macros in the bracket encoding of a tree are not
expanded until nodes are being drawn --- this way, node
specification can contain formatting instructions, as illustrated in
section~\ref{tut:basic-usage}.  However, sometimes it is useful to
expand macros while parsing the bracket representation, for example to
define tree templates such as the X-bar template, familiar
to generative grammarians:\footnote{Honestly, dynamic node creation might be a better way to do
this; see~\S\ref{ref:dynamic}.}
\begin{forestexample}[index={bracketset,action character}]
  ~\bracketset{action character=@}~
  \def\XP#1#2#3{#1P[#2][#1'[#1][#3]]}
  \begin{forest}
    [~@~\XP T{DP}{~@~\XP V{DP}{DP}}]
  \end{forest}
\end{forestexample}
In the above example, the |\XP| macro is preceded by the \emph{action character} |@|: as
the result, the token following the action character was expanded before the parsing proceeded.

The action character is not hard coded into \foRest;.  Actually, there is no action character by
default.  (There's enough special characters in \foRest; already, anyway, and the situations where
controlling the expansion is preferable to using the pgfkeys interface are not numerous.)  It is
defined at the top of the example by processing key \index{action character} in the
|/bracket| path; the definition is local to the \TeX\ group.

Let us continue with the description of the expansion control facilities of the bracket parser.
The expandable token following the
action character is expanded only once.  Thus, if one defined macro
|\VP| in terms of the general |\XP| and tried to use it in the same
fashion as |\XP| above, he would fail.  The correct way is to follow
the action character by a braced expression: the braced expression
is fully expanded before bracket-parsing is resumed.
\begin{forestexample}[index={bracketset,action character}]
  \bracketset{action character=@}
  \def\XP#1#2#3{#1P[#2][#1'[#1][#3]]}
  \def\VP#1#2{\XP V{#1}{#2}}
  \begin{forest}
    [@\XP T{DP}{~@{~\VP{DP}{DP}~}~}]
  \end{forest}
\end{forestexample}

In some applications, the need for macro expansion might be much
more common than the need to embed formatting instructions.
Therefore, the bracket parser provides commands |@+| and |@-|: |@+|
switches to full expansion mode --- all tokens are fully expanded
before parsing them; |@-| switches back to the default mode, where
nothing is automatically expanded.
\begin{forestexample}[index={bracketset,action character}]
  \bracketset{action character=@}
  \def\XP#1#2#3{#1P[#2][#1'[#1][#3]]}
  \def\VP#1#2{\XP V{#1}{#2}}
  \begin{forest} ~@+~
    [\XP T{DP}{\VP{DP}{DP}}]
  \end{forest}
\end{forestexample}

All the action commands discussed above were dealing only with
\TeX's macro expansion.  There is one final action command, |@@|,
which yields control to the user code and expects it to call
|\bracketResume| to resume parsing.  This is useful to e.g.\
implement automatic node enumeration:
\begin{forestexample}[index={bracketset,action character,option>phantom,delay,where option,option>level,content}]
  \bracketset{action character=@}
  \newcount\xcount
  \def\x#1{~@@~\advance\xcount1
    \edef\xtemp{[$\noexpand\times_{\the\xcount}$[#1]]}%
    \expandafter\bracketResume\xtemp
  }
  \begin{forest}
    phantom,
    delay={where level=1{content={\strut #1}}{}}
    ~@+~
    [\x{f}\x{o}\x{r}\x{e}\x{s}\x{t}]
  \end{forest}
\end{forestexample}
This example is fairly complex, so let's discuss how it works.  |@+| switches to the full
expansion mode, so that macro |\x| can be easily run.  The real magic hides in this macro.  In
order to be able to advance the node counter |\xcount|, the macro takes control from \foRest; by
the |@@| command.  Since we're already in control, we can use |\edef| to define the node content.
Finally, the |\xtemp| macro containing the node specification is expanded with the resume command
sticked in front of the expansion.



\section{Reference}
\label{sec:reference}

This section documents all publicly exposed keys and macros defined by the core package.  All other
commands defined by the package (see the implementation typeset in |forest.doc|) are considered
internal and might change without prior notice or compatibility support.

\subsection{Package loading and options}
\label{ref:package-options}

Load the package by writing |\usepackage{forest}| in the document preamble.

Field-specific definitions and defaults are stored in separate libraries.  Use
|\usepackage[|\meta{library name}|]{forest}| to load library \meta{library name} and its defaults
alongside the main package.  Loading several libraries in this way is allowed: however, if you need
more control over loading the defaults, use the following macros.

\begin{syntax}
\indexitem{macro>useforestlibrary}[|*|]|{|\meta{library}|,...}|
Loads the given libraries.

The starred version applies their defaults as well, while the starless does not.

Multiple library names can be given, separated by commas.  This macro can only be used in the
preamble.

\indexitem{macro>forestapplylibrarydefaults}|{|\meta{library name},...|}|
Loads the default settings of \meta{library}.

Multiple library names can be given, separated by commas.  This macro can be used either in the
preamble or in the document body. Its effect is local to the current \TeX\ scope.
\end{syntax}

For example, the |linguistics| library defines c-command related nodewalks, changes the default
parent--child edges to south--north (the main package default is border--border) and sets the
baseline to the root node.  Thus, if you write |\usepackage[linguistics]{forest}| in your preamble,
or use macro \cmdname{forestapplylibrarydefaults} like below, you get the following:

\begin{forestexample}[tree bin=minipage,index={for step,c-commanded}]
  package defaults:
  \begin{forest}
    [VP % cannot use "for c-commanded" below!
      [DP, for sibling={for tree=red}]
      [V'[V][DP]]
    ]
  \end{forest}\\[1ex]
  |linguistics| library defaults:
  ~\forestapplylibrarydefaults{linguistics}~
  \begin{forest}
    [VP
      [DP, ~for c-commanded~={red}]
      [V'[V][DP]]
    ]
  \end{forest}  
\end{forestexample}

\begin{syntax}
\indexitem(false){package option>external}|=|\alternative{true,false}

  Enable/disable externalization, see \S\ref{ref:externalization}.
  
\indexitem(most){package option>compat}|=|\meta{keylist}

Enters compatibility mode with previous versions of the \foRest; package. If at all possible, each
backwards incompatible change is given a key in the |compat| path, e.g.\
|compat=|\index{1.0-forstep} reverts to the old behaviour of spatial propagators \index{for
  step=\meta{step}}, where a propagator could not fail. To load all compatibility features, write
|compat=|\indexdef{option of=compat>all}.  To load those most likely to be useful, write
|compat=|\indexdef{option of=compat>most} or simply |compat|; these keys are also guaranteed to not
disrupt any new functionality of the package.  To load all/most compatibility features since version
|x.y|, write |x.y-all| or |x.y-most|.

Specifying this option also defines macro \indexdef{macro>forestcompat} (taking the same arguments
as the package option) which can be used to enable compatibility features locally, within the
document body.

For a list of compatibility features, see \S\ref{sec:changelog}.

By default, the package warns when a compatibility feature is used.  Disable this behaviour by
|compat=|\indexdef{option of=compat>silent}.

\indexitem(true){package option>tikzcshack}|=|\alternative{true,false}

  Enable/disable the hack into \TikZ;'s implicit coordinate syntax, see
  \S\ref{ref:relative-node-names}.

\indexitem(true){package option>tikzinstallkeys}|=|\alternative{true,false}

  Install certain keys into the \keyname{/tikz} path.  Currently: \index{fit to}.
  
\indexitem(true){package option>debug}|=|\alternative{true,false}

  Prints out some debugging info to the log file.

  \begin{advise}
  \item Use simply as |debug| (without |=true|), as it is anticipated that a future version might
    introduce categories of debugging information. For now we can debug only nodewalks.
  \end{advise}
\end{syntax}

\subsection{Invocation}
\label{sec:invocation}

\begin{syntax}
  %%% begin listing region: forest_environment_doc
\indexitem{environment>forest={[\texttt{(}\meta{stages}\texttt{)}]\meta{tree}}}
  %%% end listing region: forest_environment_doc
\indexitem{macro>Forest}[*][|(|\meta{stages}|)|]\marg{tree}

  The environment and the starless version of the macro introduce a group; the starred macro does
  not, so the created nodes can be used afterwards, like in the example below.  (Note that this will
  leave a lot of temporary macros lying around.  This shouldn't be a problem, however, since all of
  them reside in the |\forest| ``namespace''.)

  \meta{stages}, if given, overrides the contents of style \index{stages} for the current
  environment/macro.

{\tikzexternaldisable
\begin{forestexample}
    We create a
    ~\Forest*~{
      [DP,name=DP,baseline
        [D]
        [NP]
      ]
    }
    and merge it into a 
    ~\Forest*~{
      [VP,baseline
        [V]
        [,replace by=DP
        ]
      ]
    }
\end{forestexample}}

\indexitem{macro>forestset}\marg{keylist}
  
  Execute \meta{keylist} (of node keys) with the default path set to \keyname{/forest}.
  \begin{advise}
  \item This macro is usually used to define \foRest; styles.
  \item Usually, no current node is set when this macro is called.  Thus, executing most node keys
    in this place will fail. However, if you have some nodes lying around, you can use
    propagator \index{for step=\index{option>name}}|=|\meta{node name} to set the node with the given name as
    current.
  \end{advise}
\end{syntax}


\subsection{The bracket representation}
\label{ref:bracket}

A bracket representation of a tree is a token list with the following syntax:
\begin{eqnarray*}
  \meta{tree}&=&\left[\meta{preamble}\right]\meta{node}\\
  \meta{node}&=&\texttt{[}\left[\meta{content}\right]\left[\texttt{,}\meta{keylist}\right]
                 \left[\meta{children}\right]\texttt{]}\meta{afterthought}\\
  \meta{preamble}&=&\meta{keylist}\\
  \meta{keylist}&=&\meta{key--value}\left[,\meta{keylist}\right]\\
  \meta{key--value}&=&\meta{key}\OR\meta{key}\texttt{=}\meta{value}\\
  \meta{children}&=&\meta{node}\left[\meta{children}\right]
\end{eqnarray*}

The \meta{preamble} keylist is stored into keylist register \index{preamble}.  The \meta{keylist} of
a \meta{node} is stored into keylist option \index{given options}.  \meta{content} and
\meta{afterthought} are normally stored by prepending and appending
\index{content}|'=|\meta{content} and \index{afterthought}|=|\meta{afterthought} to \index{given
  options}, respectively; this is customizable via \index{content to} and redefining style
\index{afterthought}.

Normally, the tokens in the bracket representation are not expanded while the input is parsed.
However, it is possible to control expansion.  Expansion control sequences of \foRest;'s bracket
parser are shown below.  Note that by default, there is no \index{action character}.
\begin{center}
  \begin{tabular}{ll}
    \rstyle\meta{action character}\texttt{-}&no-expansion mode (default): nothing is expanded\\
    \rstyle\meta{action character}\texttt{+}&expansion mode: everything is fully expanded\\
    \rstyle\meta{action character}\texttt{}\meta{token}&expand \meta{token}\\
    \rstyle\meta{action character}\texttt{}\meta{\TeX-group}&fully expand \meta{\TeX-group}\\
    \rstyle\meta{action character}\meta{action character}&yield control;\\&upon finishing its job,
    user's code should call \indexdef{macro>bracketResume}
  \end{tabular}
\end{center}

To customize the bracket parser, call
\indexdef{macro>bracketset}\meta{keylist}, where the keys can be the following. 
\begin{syntax}
\indexitem({{[%]
  }}){bracket key>opening bracket}|=|\meta{character}
\indexitem({{{{%[
        ]}}}}){bracket key>closing bracket}|=|\meta{character}
\indexitem(none){bracket key>action character}|=|\meta{character}
\end{syntax}

By redefining the following two keys, the bracket parser can be used outside \foRest;.
\begin{syntax}
\indexitem{bracket key>new node}|=|\meta{preamble}\meta{node specification}\meta{csname}.
  Required semantics: create a new node given the preamble (in the case of a new
  root node) and the node specification and store the new node's id into \meta{csname}. 
\indexitem{bracket key>set afterthought}|=|\meta{afterthought}\meta{node id}.
  Required semantics: store the afterthought in the node with given id.
\end{syntax}

\subsection{The workflow}
\label{sec:workflow}

\subsubsection{Stages}
\label{ref:stages}

\FoRest; does its job in several stages.  The default course of events is the following:
\begin{enumerate}
\item\label{step:parsing-bracket} The bracket representation of the tree (\S\ref{ref:bracket}) is
  parsed and stored in a data structure.
\item\label{step:given-options} The keys given in the bracket representation are processed. In
  detail, \index{default preamble} is processed first, then the given \index{preamble} (both in the
  context of the (formal) root node) and finally the keylists given to individual nodes.  The latter
  are processed recursively, in a depth-first, parent-first fashion.
\item\label{step:typeset-nodes} Each node is typeset in its own |tikzpicture| environment, saved
  in a box and its measures are taken.
\item\label{step:pack} The nodes of the tree are \emph{packed}, i.e.\ the relative positions of the nodes are
  computed so that the nodes don't overlap.  That's difficult.  The result: option \index{option>s} is
  set for all nodes.  (Sometimes, the value of \index{option>l} is adjusted as well.)
\item\label{step:compute-xy} Absolute positions, or rather, positions of the nodes relative to the
  root node are computed.  That's easy.  The result: options \index{x} and \index{y} are
  set.
\item\label{step:draw-tree} The \TikZ; code that will draw the tree is produced and executed.  (The nodes are
  drawn by using the boxes typeset in step~\ref{step:typeset-nodes}.)
\end{enumerate}

Stage~\ref{step:parsing-bracket} collects user input and is thus ``fixed''.  However, the other
stages, which do the actual work, are under user's control.

First, hooks exist between the individual stages which make it possible (and easy) to change the
properties of the tree between the processing stages.  For a simple example, see
example~(\ref{ex:adjustxy}): the manual adjustment of \index{y} can only be done after the absolute
positions have been computed, so the processing of this option is deferred by \index{before drawing
  tree}.  For a more realistic example, see the definition of style \index{GP1}: before packing,
\texttt{outer xsep} is set to a high (user determined) value to keep the $\times$s uniformly spaced;
before drawing the tree, the \texttt{outer xsep} is set to \texttt{0pt} to make the arrows look
better.

Second, the execution of the processing stages \ref{step:given-options}--\ref{step:draw-tree} is
\emph{completely} under user's control.  To facilitate adjusting the processing flow, the approach
is twofold.  The outer level: \foRest; initiates the processing by executing style \keyname{stages},
which by default executes the processing stages \ref{step:given-options}--\ref{step:draw-tree},
preceding the execution of each but the first stage by processing the keys embedded in temporal
propagators \keyname{before ...} (see \S\ref{ref:temporal-propagators}).  The inner level: each
processing step is the sole resident of a stage-style, which makes it easy to adjust the workings of
a single step.  What follows is the default content of style \keyname{stages}, including the default
content of the individual stage-styles. Both nicely readable and ready to copy-paste versions are given.
\begin{syntax}
  \indexitem{style>stages}
  \begin{syntax}
  \item \index{for step=\index{root'}}|={|
  \item |  |\index{process keylist register}|=|\index{default preamble}|,|
  \item |  |\index{process keylist register}|=|\index{preamble}
  \item |}|
  \item \index{process keylist}|=|\index{given options}
  \item \index{process keylist}|=|\index{before typesetting nodes}
  \indexitem{style>typeset nodes stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{typeset nodes}|}|
  \item \index{process keylist}|=|\index{before packing}
  \indexitem{style>pack stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{pack}|}|
  \item \index{process keylist}|=|\index{before computing xy}
  \indexitem{style>compute xy stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{compute xy}|}|
  \item \index{process keylist}|=|\index{before drawing tree}
  \indexitem{style>draw tree stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{draw tree}|}|
  \end{syntax}
\end{syntax}
\lstinputregion{forest.dtx}{stages}

Both style \keyname{stages} and the individual stage-styles may be freely modified by the user.
Obviously, as a style must be redefined before it is processed, |stages| should be redefined (using
macro \index{forestset}) outside the \index{forest} environment; alternatively, stages can be given
as the (parenthesized) optional argument of the environment (see~\S\ref{sec:invocation}).  A stage
style can also be redefined in the preamble or in any of the keylists processed prior to entering
that stage.

Here's the list of keys used either in the default processing or useful in an alternative
processing flow.
\begin{syntax}
  \indexitem{stage>typeset nodes}
  \itemnosep
  \indexitem{stage>typeset nodes'}
  
  Typesets each node of the current node's subtree in its own |tikzpicture| environment.  The result
  is saved in a box (which is used later, in the \index{draw tree stage}) and its measures are
  taken.

  In the |typeset_nodes'| variant, the node box's content is not overwritten if the box already
  exists.

  The order in which the nodes are typeset is controlled by nodewalk style \indexdef{nodewalk
    style>typeset nodes processing order} or, if this style is not defined, by \index{processing
    order}. 
  
\indexitem{node key>typeset node}  Typesets the \emph{current} node, saving the result in the node box.

  This key can be useful also in the default \index{stages}.  If, for example, the node's content
  is changed and the node retypeset just before drawing the tree, the node will be positioned as if
  it contained the ``old'' content, but have the new content: this is how the constant distance
  between $\times$s is implemented in the \index{GP1} style.

\indexitem{stage>pack} The nodes of the tree are \emph{packed}, i.e.\ the relative positions of
  the nodes are computed so that the nodes don't overlap.  The result: option \index{option>s} is set
  for all nodes; sometimes (in tier alignment and for some values of \index{calign}), the value
  of some nodes' \index{option>l} is adjusted as well.

\indexitem{node key>pack'} ``Non-recursive'' packing: packs the children of the current node only.
  (Experimental, use with care, especially when combining with tier alignment.)

\indexitem{stage>compute xy} Computes the positions of the nodes in the subtree relative to the
  current node.  The results are stored into options \index{x} and \index{y}.  The current node's
  \index{x} and \index{y} remain unchanged.

\indexitem{stage>draw tree}
\itemnosep
\indexitem{stage>draw tree'}
  Produces the \TikZ; code that will draw the tree.

  The procedure uses the node boxes typeset by \index{typeset nodes} or friends.  The |'| variant
  includes the node boxes in the picture using \cmdname{copy}, not \cmdname{box}, thereby preserving
  them.

  By default, the nodes are drawn first, followed by edges and finally the custom code given by
  \index{tikz}.  Within each task, the order in which the nodes are visited is determined by
  nodewalk styles \indexdef{nodewalk style>draw tree nodes processing order}, \indexdef{nodewalk
    style>draw tree edges processing order} and \indexdef{nodewalk style>draw tree tikz processing
    order}, respectively, with \index{processing order} as the fallback in case any of these styles
  does not exist (the default).

  However, the whole procedure is fully customizable via style \indexdef{style>draw
    tree method}, originally defined like shown below.  To draw an individual node, edge (to parent)
  or custom (\index{tikz}) code, \indexdef{node key>draw tree node}, \indexdef{node key>draw tree
    edge} and \indexdef{node key>draw tree tikz} are used, respectively.

  \lstinputregion{forest.dtx}{draw_tree_method}
  
\indexitem{node key>draw tree box}|=|[\meta{\TeX\ box}]  The picture drawn by the subsequent
  invocations of \index{draw tree} and \index{draw tree'} is put into \meta{\TeX\ box}.  If
  the argument is omitted, the subsequent pictures are typeset normally (the default).

  \indexitem{node key>process keylist}|=|\meta{keylist option}
  For each node in the entire tree, the keylist saved in \meta{keylist option} of the node is
  processed (in the context of that node).

  Note that this key is not sensitive to the current node: it processes the keylists for the whole
  tree.  Actually, it is possible to control which nodes are visited: \index{keylist option
    processing order=\meta{keylist option}} is walked if it is defined, otherwise \index{processing
    order}. In both cases, the processing nodewalk starts at the formal root of the tree (see
  \index{root'} and \index{set root}), which is reevaluated at the beginning of each internal cycle
  (see below). By default, \index{keylist option processing order=\meta{keylist option}} is indeed
  undefined, while the \index{processing order} defauls to \index{tree}, which means that \emph{all
    the nodes in the entire tree} are processed.

  Keylist-processing proceeds in cycles.  In a given cycle, the value of option \meta{keylist option
    name} is processed for every node visited by the processing nodewalk.  During a cycle, keys may
  be \emph{delayed} using key \index{delay}.  Keys delayed in a cycle are processed in the next
  cycle.  The number of cycles in unlimited. 

  Dynamic creation of nodes happens between the cycles. The options given to the dynamically
  created nodes are implicitely delayed and thus processed at the end of the next cycle.
  
  The calls of this key should \emph{not} be nested, and it should not be embedded under
  \index{process keylist'} or \index{process keylist register}.

  When changing the processing nodewalk, note that delayed keys will be executed only for nodes
  visited by the processing nodewalk.  Delayed spatially propagated keys will be remembered,
  though, and executed when the given keylist is processed for the target node.  Using spatial
  propagators without delaying cannot result in a non-processed key.

\indexitem{node key>process keylist'}|=|\meta{keylist option}\meta{nodewalk}

  This key is a variant of \index{process keylist}.  The differences are as follows.

  The processing nodewalk is given explicitely (by \meta{nodewalk}) and starts at the current node
  (in each internal cycle).

  There is no dynamic creation of nodes between the delay cycles. Any dynamic node
  instructions will be remembered and executed after the next cycle of \index{process keylist}, or
  an explicit call to \index{do dynamics}.
  
  It is safe to embed this key within \index{process keylist} and (all) friends.

\indexitem{node key>process keylist''}|=|\meta{keylist option}\meta{nodewalk}

This key is a variant of \index{process keylist} which executes neither dynamic node operations nor
delayed keys (there are thus no internal cycles).  Any delayed keys will not be processed
during the execution of this key. They will be remembered and executed at the end of the next cycle
of \index{process keylist} or \index{process keylist'}.

As for \index{process keylist'}, the processing nodewalk is given explicitely (by \meta{nodewalk})
and starts at the current node.

It is safe to embed this key within \index{process keylist} and (all) friends.
  
\indexitem{node key>process keylist register}|=|\meta{register}

  Process the keylist saved in \meta{register} in the context of the current node.

  Any delayed keys will not be processed during the execution of this key. They will be
  remembered and executed at the end of the next cycle of \index{process keylist} or
  \index{process keylist'}.

  It is safe to embed this key within \index{process keylist} or \index{process keylist'}.

\indexitem{node key>process delayed}|=|\meta{nodewalk} Process delayed keys.

  Keylist \index{delay} cannot be processed using \index{process keylist} or \index{process
    keylist'}. Thus this key.

  Like \index{process keylist} or \index{process keylist'}, this key uses internal cycles.  Thus,
  any embedded \index{delay}s will be processed.

  There is no dynamic creation of nodes between the delay cycles. Any dynamic node instructions will
  be remembered and executed after the next cycle of \index{process keylist} or \index{process
    keylist'}, or an explicit call to \index{do dynamics}.
  
  This key is safe to use within \index{process keylist}, \index{process keylist'} and
  \index{process keylist register}.
  
\indexitem(tree){nodewalk style>processing order}|=|\meta{nodewalk}

Redefine this style to change the default order in which \index{process keylist} processes a keylist
option.  For example, to process the nodes in a child-first fashion, write
\begin{lstlisting}
  for nodewalk={processing order/.style={tree children first}}
\end{lstlisting}
Note that this is a \emph{nodewalk} style, so it must be defined during a nodewalk.

\indexitem(processing order)[form={processing order}]{word suffix=keylist option>nodewalk style>processing order=\meta{keylist option}}|=|\meta{nodewalk}

Redefine this style to change the \index{process keylist} processing order for a specific
\meta{keylist option}.  For example, to process \index{before drawing tree} options in the
child-first fashion, leaving the processing of other |before ...| keylists untouched, write
\begin{lstlisting}
  for nodewalk={before drawing tree processing order/.style={tree children first}}
\end{lstlisting}

\indexitem{node key>do dynamics} Experimental. Perform pending dynamic tree operations.

  Do not use this key within \index{process keylist} or \index{process keylist'}.

\end{syntax}

\subsubsection{Temporal propagators}
\label{ref:temporal-propagators}

Temporal propagators delay processing of given keys until some other point in the processing of the
tree.  There are three kinds of temporal propagators.  Most of the |before_...| and |after_...|
propagators defer the processing of the given keys to a hook just before some stage in the workflow
(\S\ref{ref:stages}).  \index{before packing node} and \index{after packing node} are special as
they fire \emph{during} the packing stage.  The \keyname{delay} propagator is ``internal'' to the
current hook: the keys in the hook are processed cyclically, and \keyname{delay} delays the
processing of the given keys until the next cycle.

Formally, temporal propagators are keylist options (except \index{delay n}, which is a style), so
augmented assignments are possible (\S\ref{sec:option-setting}).

All temporal propagators can be nested without limit.

\begin{advise}
\item A note on typos.
  
  By default, all keys unknown to \foRest; are appended to keylist option \index{node options} The
  value of \index{node options} is fed to \TikZ; when typesetting a node, so any typos are caught by
  \TikZ;. However, as nodes are normally typeset in stage \index{typeset nodes stage}, any typos in
  keys temporally propagated past that stage will not be noticed, simply because noone will use the
  value of \index{node options} where they end up (the exception being nodes which are explicitely
  retypeset by the user using \index{typeset node}).

  To sum up, typos in any keys temporally propagated by \index{before packing}, \index{before
    packing node}, \index{after packing node}, \index{before computing xy} and \index{before drawing
    tree} will be silently ignored.  This is probably not what you want, so double-check everything
  you write there.

  Using \index{unknown to}|=|\index{unknown key error}, it is possible to change the default
  behaviour.  You will catch all typos if you append the command to \index{pack stage}, as shown
  below.  This can be done either in the tree or by \index{forestset}.

\begin{lstlisting}
  typeset nodes stage/.append style={unknown to=unknown key error}
\end{lstlisting}

  Of course, this makes it impossible to write simply
  |before_drawing_tree={inner_sep=5pt,_typeset_node}|.  Any |tikz|'s options must be given
  explicitely via \index{node options}:
  |before_drawing_tree={node_options={inner_sep=5pt},_typeset_node}|.
\end{advise}

\begin{syntax}
\indexitem{propagator>delay}|=|\meta{keylist} Defers the processing of the \meta{keylist} until the next
  cycle.

  Internally, |delay| is a keylist option, so augmented operators of the \index{keylist} type can be
  used.

  To check whether any keys were delayed, use conditional \index{if have delayed}.
\indexitem{propagator>delay n}|=|\meta{integer}\meta{keylist} Defers the processing of the
  \meta{keylist} for $n$ cycles.  $n$ may be $0$, and it may be given as a |pgfmath| expression.
  
\indexitem{propagator>given options}
  
  When \index{stages} processing starts, this list holds the keys given by the user in the
  bracket representation.
  
\indexitem{propagator>before typesetting nodes}|=|\meta{keylist} Defers the processing of the
  \meta{keylist} to until just before the nodes are typeset.

\indexitem{propagator>before packing}|=|\meta{keylist}
  
\indexitem{propagator>before packing node}|=|\meta{keylist}

  Defers the processing of the \meta{keylist} given to the node to until just before/after the
  subtree of \emph{this specific node} is packed.  Even before packing node, the (subtrees of the)
  children of the node have already been packed.\footnote{\FoRest; employs two variants of the
    packing algorithm: the faster one is used for (parts of) trees with uniform growth, i.e.\
    subtrees where \index{grow} does not change; the slower, generic variant is used in where this
    is not the case.  Now, the fast method works by dealing with l and s dimension separately, and
    it is able to do this for the entire (sub)tree, without needing to invoke the packing method for
    its constituents.  The consequence is that there is no place where \index{before packing node}
    could be called meaningfully, as the node's constituents are not packed individually, ``just
    before packing the current node'' is the same as ``just before packing the tree'', and for many
    nodes packing is not called anyway in the fast method.  As the rationale behind \index{before
      packing node} is to be able to adjust the options of the subtree based on the information
    gained by packing its constituents, specifying \index{before packing node} automatically
    switches to the generic method.}  \indexitem{propagator>after packing node}|=|\meta{keylist} Defers
  the processing of the \meta{keylist} given to the node to until just after \emph{this specific
    node} is packed.

\begin{forestexample}[index={after packing node,no edge,calign,value=calign>first,option>l,l sep,content format,content,if option,n children,pgfmath,option>s,max x,min x,for step,step>children,wrap pgfmath arg,typeset node,dimen+=s}]
  \forestset{box/.style={
    draw, no edge, l=0, l sep=1.5ex, 
    calign=first, anchor=base west,
    content format={\strut\forestoption{content}},
    if n children=0{}{
      ~after packing node~={
        minimum width/.pgfmath=
          {s("!l")+max_x("!l")-s("!1")-min_x("!1")},
        for children/.wrap pgfmath arg={s+={##1}}{0},
        typeset node}}}}
  \begin{forest} for tree={box} [/
    [home[saso[Download][TeX]][alja][joe]]
    [usr[bin][share]]]
  \end{forest}    
\end{forestexample}
  
  \begin{advise}
  \item Remember to typeset or pack the node using \index{pack'} if you have changed options
    influencing the typesetting or packing process.
  \end{advise}

\indexitem{propagator>before computing xy}|=|\meta{keylist}  Defers the processing of the
  \meta{keylist} to until just before the absolute positions of the nodes are computed.
\indexitem{propagator>before drawing tree}|=|\meta{keylist}  Defers the processing of the
  \meta{keylist} to until just before the tree is drawn.
\end{syntax}

\subsubsection{Spatial propagators}
\label{ref:spatial-propagators}

Spatial propagators pass the given \meta{keylist} to other node(s) in the tree.

\FoRest; provides many spatial propagators.  Almost all of them are built from long-form nodewalk
steps using prefix \index{for step}.  This is why the list below is so short: it only documents
this prefix and the exceptions.  For the list of nodewalk steps, see \S\ref{ref:nodewalks}.

Spatial propagation does not change the current node: after visiting the nodes the keys are
propagated to, a spatial propagator (silently) returns to the origin of the embedded nodewalk.

\begin{syntax}
\indexitem{word prefix=step>propagator>for=\meta{step}}|=|\meta{arg$_1$}|...|\meta{arg$_n$}\meta{keylist}

  Walks the (single- or multi-step) \meta{step} from the current node and executes the given
  \meta{keylist} at every visited node.  The current node remains unchanged.

  \meta{step} must be a long-form nodewalk step.  If it has any arguments, they should be given
  before the keylist, with one exception: \meta{keylist: every-step} arguments of embedded nodewalks
  should be omitted, as it makes no sense to provide the every-step keylist twice.

  For details on nodewalk steps, see \S\ref{ref:nodewalks}.
  
  Examples:
  \begin{itemize}
  \item |for_parent={l_sep+=3mm}|
  \item |for_n=2{circle,draw}|
  \item |for_nodewalk={uu2}{blue}|
  \item |for_tree={s_sep+=1em}|
  \end{itemize}

\indexitem{propagator>for tree'}|=|\meta{keylist 1}\meta{keylist 2} A ``combination'' of
  \index{for step=\index{tree children-first}} and \index{for step=\index{tree}}.

  Passes the keylists to the current node and its the descendants.  At each node, the \meta{keylist
    1} is processed first; then, children are processed recursively; finally, \meta{keylist 2}
  is processed.

  For an example, see the definition of \index{draw brackets} from \reflibrary{linguistics}.
  
\indexitem{propagator>for 1}, \dots\indexdef[not print]{propagator>for 2}\indexdef[not print]{propagator>for 3}\indexdef[not print]{propagator>for 4}\indexdef[not print]{propagator>for 5}\indexdef[not print]{propagator>for 6}\indexdef[not print]{propagator>for 7}\indexdef[not print]{propagator>for 8}, \indexdef{propagator>for 9}|=|\meta{keylist}
  \itemnosep
\indexitem{propagator>for -1}, \dots\indexdef[not print]{propagator>for -2}\indexdef[not print]{propagator>for -3}\indexdef[not print]{propagator>for -4}\indexdef[not print]{propagator>for -5}\indexdef[not print]{propagator>for -6}\indexdef[not print]{propagator>for -7}\indexdef[not print]{propagator>for -8}, \indexdef{propagator>for -9}|=|\meta{keylist}

  Although \index{for step} normally cannot precede short forms of steps, an exception is made
  for \index{ss 1}\index[not print]{ss 2,ss 3,ss 4,ss 5,ss 6,ss 7,ss 8}, \dots, \index{ss 9}. (These keys will work even if the short steps are redefined.)

  |for |$n$ passes the \meta{keylist} to the $n$th child of the current node.  |for -|$n$ starts counting at the last child.
\indexitem{node key>Nodewalk}|=|\meta{keylist: config}\meta{nodewalk}\meta{keylist: every-step}

Configures and executes the \meta{nodewalk}.  This key is a nodekey-space copy of nodewalk step
\index{step>Nodewalk}.

  \begin{advise}
  \item Use this key carefully as it can change the current node!
  \item The envisioned purpose of this key is to change the current node within the every-step
    keylist of (an outer) nodewalk, where only node keys are accepted.  The config defaults
    (independent every-step, shared history) are set to facilitate that purpose.
  \end{advise}
  
\indexitem{node key>node walk}|=|\meta{node walk} \textbf{Deprecated!!!} Please use \index{for
    step=\index{nodewalk}} in new code.  From the old documentation:

  \begin{quote}
    This is the most general way to use a \meta{node walk}.

    Before starting the \meta{node walk}, key \indexdef{node key>node walk/before walk} is processed.
    Then, the \meta{step}s composing the \meta{node walk} are processed: making a step (normally)
    changes the current node.  After every step, key \indexdef{node key>node walk/every step} is
    processed.  After the walk, key \indexdef{node key>node walk/after walk} is processed.

    \keyname{node walk/before walk}, \keyname{node walk/every step} and \keyname{node walk/after
      walk} are processed with \keyname{/forest} as the default path: thus, \foRest;'s node keys can
    be used normally inside their definitions.

    \begin{advise}
    \item Node walks can be tail-recursive, i.e.\ you can call another node walk from \keyname{node
        walk/after walk} --- embedding another node walk in \keyname{node walk/before walk} or
      \keyname{node walk/every step} will probably fail, because the three node walk styles are not
      saved and restored (a node walk doesn't create a \TeX\ group).
    \item \keyname{every step} and \keyname{after walk} can be redefined even during the walk.
      Obviously, redefining \keyname{before walk} during the walk has no effect (in the current
      walk).
    \end{advise}
  \end{quote}
\end{syntax}

\subsection{Node keys}
\label{ref:node-keys}

\FoRest; is mostly controlled using \PGF;'s key management utility |pgfkeys|
\citep[\S55]{tikzpgf2.10}.  Most of the keys can be given next to the content in the bracket
representation of a tree (\S\ref{ref:bracket}): we call these \emph{node keys}.  Some keys,
notably \emph{nodewalk steps} (\S\ref{ref:nodewalks}), must be used as arguments of specific
commands.

Most node keys perform some operation on the \emph{current node}.  When the keylist given after the
content of a node is processed, the current node is set to that node.  However, the current node can
be temporarily changed, for example by spatial propagators (\S\ref{ref:spatial-propagators}) or,
more genarally, nodewalks (\S\ref{ref:nodewalks}).

The most common function that node keys perform is to set or modify an \emph{option} of the current
node (\S\ref{sec:options-and-registers}), usually to determine the appearance or position of the
node and its edge (\S\ref{sec:formatting-tree}), but there are also several kinds of more exotic
keys like spatial (\S\ref{ref:spatial-propagators}) propagators, which temporarily change the
current node, temporal (\S\ref{ref:temporal-propagators}) propagators, which delay the processing of
the keylist until some other stage in the workflow, keys that dynamically create and move nodes
(\S\ref{ref:dynamic}), keys that control the way \foRest; processes the tree (\S\ref{ref:stages})
etc.  Finally, users can also define their own keys, either by defining |pgfkeys| styles\footnote{%
  Styles are a feature of the \keyname{pgfkeys} package.  They are named keylists, whose usage
  ranges from mere abbreviations through templates to devices implementing recursion.  To define a
  style, use \PGF;'s handler \keyname{.style} \citep[\S55.4.4]{tikzpgf2.10}: \meta{style
    name}\keyname{/.style=}\meta{keylist}.} \citep[\S55.4.4]{tikzpgf2.10} or using \foRest;'s option
declaration mechanism (\S\ref{sec:option-declaring}).

\begin{advise}
\item The style definitions and option declarations given among the other keys in the bracket
  specification are local to the current tree (but note that \foRest;'s keylist processing,
  including temporal and spatial propagation, introduces no groups).  To define globally accessible
  styles and options (well, they are always local to the current \TeX\ group), use
  macro \cmdname{forestset} outside the \index{forest} environment, e.g.\ in the preamble of the
  document.  (Although \index{forestset}\meta{keylist} is currently equivalent to
  \cmdname{pgfkeys}\texttt{\{/forest,}\meta{keylist}\texttt{\}}, don't rely on this as it will
  change in some (near) future version of the package, as there is a plan to introduce namespaces
  \dots)
\end{advise}

The remainder of this section lists the general-purpose node keys, i.e.\ those which don't deal with
tree formatting.

\begin{syntax}

\indexitem{style>afterthought}|=|\meta{toks}  Provides the afterthought explicitely.

  This key is normally not used by the end-user, but rather called by the bracket parser.  By
  default, this key is a style defined by |afterthought/.style={tikz+={#1}}|: afterthoughts are
  interpreted as (cumulative) \TikZ; code.  If you'd like to use afterthoughts for some other
  purpose, redefine this style --- this will take effect even if you do it in the tree preamble.

\indexitem{node key>autoforward}|=|\meta{option}\meta{keylist}, \indexdef{node key>autoforward register}|=|\meta{register}\meta{keylist}
\itemnosep
\indexitem{node key>autoforward'}|=|\meta{option}\meta{keylist}, \indexdef{node key>autoforward register'}|=|\meta{register}\meta{keylist}

Whenever the value of an autoforwarded option or register is given or changed (via an augmented
assignment), \meta{option}|=|\meta{new value} or \meta{register}|=|\meta{new value} is appended to
\meta{keylist}.  This can be used to ``intercept and remember'' \TikZ; options, like \index{option>anchor}
and \index{rotate}.

  The |autoforward'| variant keeps only a single instance of \meta{option} in \meta{keylist}.

  If you ever need to use the non-forwarded version of the key, prefix it with word |autoforwarded|,
  e.g.\ |autoforwarded_rotate|.  Autoforwarding is limited to the current \TeX\ group.

\indexitem{node key>Autoforward}|=|\meta{option}\meta{style definition}, \indexdef{node key>Autoforward register}|=|\meta{register}\meta{style definition}

This is a more generic variant of autoforwarding.  After the value of an option or register
autoforwarded with this key is changed, the style defined by \meta{style definition} is called with
the new option/register value as its argument.

\begin{forestexample}[index={Autoforward,content,node options}]
  \forestset{~Autoforward~={content}{node options={#1}}}
  \begin{forest}
    [red[blue][green]]
  \end{forest}
\end{forestexample}

\indexitem{node key>unautoforward}|=|\meta{option or register} Undoes the autoforwarding of the
option or register made by any of the autoforwarding keys. 

\indexitem{node key>content to}|=|\meta{key} When parsing the bracket representation of the tree,
store the given content using \meta{key}|=|\meta{content}.

\indexitem{node key>copy command key}|=|\meta{pgfkey: source}\meta{pgfkey: destination}
  
  Copies the |pgf| key in a way that |.add code| and |.add style| handlers still work.

\indexitem({{{{{}}}}}){register>default preamble}|=|\meta{keylist}
  \itemnosep
\indexitem{register>preamble}|=|\meta{keylist}

  These registers hold the content of the default preamble and the preamble of the current tree.

  |preamble| is set by the bracket parser. Set |default preamble| outside the \index{forest}
  environment using \index{forestset}.

  As |default preamble| and |preamble| are not styles but keylist registers, the |#| characters do
  not need to be doubled: you can freely copy and paste your keylists between the node options of
  the root node, the preamble and the default preamble. The only difference will be the order of
  execution: first default preamble, then preamble, and finally the root node's options.
  
\indexitem{node key>split}|=|\meta{toks}\meta{separator}\meta{keylist}
  \itemnosep
\indexitem{node key>split option}|=|\meta{option}\meta{separator}\meta{keylist}
  \itemnosep
\indexitem{node key>split register}|=|\meta{register}\meta{separator}\meta{keylist}

Split \meta{toks} or the value of \meta{option} or \meta{register} at occurrences of
\meta{separator} (which must be a single token), and process the keys in \meta{keylist} with the
pieces of the split token list as arguments, in the order given.

  The keys in \meta{keylist} can be any valid keys, including augmented assignments, non-current
  option assignments, even \index{TeX}.

  The difference in the number of split values and given keys is handled gracefully.  If there is
  not enough values, the superfluous keys are not processed; if there are too many values, the last
  key is called repeatedly.

  For an example, see \S\ref{sec:example-decision-tree}.
  
\indexitem{node key>TeX}|=|\meta{toks: \TeX\ code} The given code is executed immediately.

  This can be used for e.g.\ enumerating nodes:
\begin{forestexample}[point=TeX,index={TeX,delay,where option,tier,content,GP1},label=ex:enumerate]
  \newcount\xcount
  \begin{forest} GP1,
    delay={TeX={\xcount=0},
      where tier={x}{TeX={\advance\xcount1},
         content/.expanded={##1$_{\the\xcount}$}}{}}
    [
      [O[x[f]]]
      [R[N[x[o]]]]
      [O[x[r]]]
      [R[N[x[e]]][x[s]]]
      [O[x[t]]]
      [R[N[x]]]
    ]
  \end{forest}
\end{forestexample}

\indexitem{node key>TeX'}|=|\meta{toks: \TeX\ code} This key is a combination of keys \index{TeX}
and \index{TeX''}: the given code is both executed and externalized.

\indexitem{node key>TeX''}|=|\meta{toks: \TeX\ code} The given code is externalized, i.e.\ it will be
executed when the externalized images are loaded.

The image-loading and \keyname{TeX'(')} produced code are intertwined.

\indexitem{node key>typeout}|=|\meta{toks} A \foRest; version of \LaTeX\ macro |\typeout|. Useful
for debugging, trust me on this one.
  
\indexitem(node options){node key>unknown to}|=|\meta{key} Forward unknown keys to \meta{key}.

\begin{advise}
\item Do \emph{not} use handler |.unknown| to deal with unknown keys, as it is used internally by
\foRest;, and is set up to make it possible to set options of non-current nodes (see
\S\ref{sec:option-setting}).
\end{advise}

\indexitem{node key>unknown key error}|=|\meta{keyval} Produces an error.

Write \index{unknown to}|=unknown key error| to produce an error when a key unknown to \foRest; is
used.

\end{syntax}



\subsection{Options and registers}
\label{sec:options-and-registers}

\FoRest; introduces two types of data storage: \emph{node options} (or just \emph{options} for
short) and \emph{registers}.

Options store data related to particular nodes.  Each node has its own set of option values, i.e.\
the value of an option at some node is independent of its value at other nodes: in particular,
setting an option of a node does \emph{not} set this option for the node's descendants.  Register
values are not associated to nodes.

Note that option and register keys share the same ``namespace'' (|pgfkeys| path and |pgfmath|
function names) so it is not possible to have an option and a register of the same name!

\subsubsection{Setting}
\label{sec:option-setting}

The simplest way to set the value of an option or a register is to use the key of the same name.
\begin{syntax}
  \indexitem[index key={@@@opt},form={}]{prefix>assignment>current node=\meta{option}}|=|\meta{value}
  Sets the value of \meta{option} of the current node to \meta{value}.

  Note that option types \index{keylist} and \index{autowrapped toks} redefine this basic key.

  \indexitem[index key={@@@reg},form={}]{prefix>assignment>current node=\meta{register}}|=|\meta{value}
  Sets the value of \meta{register} to \meta{value}.

  Note that register types \index{keylist} and \index{autowrapped toks} redefine this basic key.
\end{syntax}

Options can also be set for the non-current node:
\begin{syntax}
  % \indexitem[index key={@@@.},form={.},+print format={+result={\index(not print){relative node name}\index(not index)[+print format=definition]{relative node name}}},+index format={+result={\meta{relative node name}}}]{prefix>assignment>relative node=\meta{option}}|=|\meta{value}
  \indexitem[index key={@@@.},form={.},+print format={+result={\index{relative node name}}},+index format={+result={\meta{relative node name}}}]{prefix>assignment>relative node=\meta{option}}|=|\meta{value}

  Sets the value of \meta{option} of the node specified by \meta{relative node name} to \meta{value}.

  Notes: \begin{enumerate*}[(i)]
  \item\emph{\meta{value} is evaluated in the context of the current node.}
  \item In general, the resolution of \meta{relative node name} depends on the
    current node; see \S\ref{ref:relative-node-names}.
  \item \meta{option} can also be an ``augmented assignment operator'' (see below) or, indeed, any
    node key.
  \end{enumerate*}  
\end{syntax}

Additional keys for setting and modifying the value of an option or a register exist, depending on
its data type.  Informally, you can think of these keys as \emph{augmented operators} known from
various programming languages.

\begin{syntax}
\indexitem{type>toks} contains \TeX's \meta{balanced text} \citep[275]{texbook}.

  A toks \meta{option} additionally defines the following keys:
  \begin{syntax}
  \indexitem{suffix>augmented assignment=toks>+=\meta{option}}|=|\meta{toks} appends the given \meta{toks} to the
    current value of the option.
    
  \indexitem{prefix>augmented assignment=toks>+=\meta{option}}|=|\meta{toks} prepends the given \meta{toks} to the
    current value of the option.
    
  % \item \index{if in toks option=\meta{toks option}}| =|\meta{toks}\meta{true
  %   keylist}\meta{false keylist} checks if \meta{toks} occurs in the option value; if it does,
  %   \meta{true keylist} are executed, otherwise \meta{false keylist}.
    
  % \item \index{where in toks option=\meta{toks option}}| =|\meta{toks}\meta{true
  %   keylist}\meta{false keylist} is a style equivalent to \index{for step=\index{tree}}|={|\keyname{if in }\meta{option}=\meta{toks}\meta{true keylist}\meta{false keylist}|}|: for every node in
  %   the subtree rooted in the current node, \keyname{if in }\meta{option} is executed in
  %   the context of that node.
  \end{syntax}

\indexitem{type>autowrapped toks} is a subtype of \index{toks} and contains \TeX's \meta{balanced
text} \citep[275]{texbook}. 

  {\rstyle\meta{option}}|=|\meta{toks} of an autowrapped \meta{option} is redefined to
  \meta{option}|/|\index{wrap value}|=|\meta{toks} of a normal \meta{toks} option.
  
  Keyvals \indexdef{suffix>augmented assignment=autowrapped toks>+=\meta{option}}|=|\meta{toks} and
  \indexdef{prefix>augmented assignment=autowrapped toks>+=\meta{option}}|=|\meta{toks} are redefined to
  \index{toks+=\meta{option}}|/|\index{wrap value}|=|\meta{toks} and
  \index{+toks=\meta{option}}|/|\index{wrap value}|=|\meta{toks}, respectively.  The normal toks
  behaviour can be accessed via keys \indexdef{suffix>augmented assignment=autowrapped toks>'=\meta{option}},
  \indexdef{suffix>augmented assignment=autowrapped toks>+'=\meta{option}}, and
  \indexdef[set={print format={result/.expanded=+\forestoption{argument}',pgfkey},index form=+\meta{autowrapped toks option}',index format=pgfkey,index key=+'}]{augmented assignment>+autowrapped toks'=\meta{option}}.

\indexitem{type>keylist} is a subtype of \index{toks} and contains a comma-separated list of
  \meta{key}[|=|\meta{value}] pairs.

  Augmented assignment operators \indexdef{suffix>augmented assignment=keylist>+=\meta{option}} and
  \indexdef{prefix>augmented assignment=keylist>+=\meta{option}} automatically insert a comma
  before/after the appended/prepended material. 
  
  Augmented assignment operator \indexdef{suffix>augmented assignment=keylist>-=\meta{option}}|=|\meta{keylist} deletes the keys
  from keylist \meta{option}.  \meta{keylist} specifies which keys to delete. If a key is given no
  value, all occurrences of that key will be deleted.  If a key is given a value, only occurrences
  with that value will be deleted.  To delete occurrences without value, use special value
  \indexdef{macro>forestnovalue}.  (Note: if you include a key in \meta{keylist} more than once,
  only the last occurrence counts.)

  {\rstyle\meta{option}}|=|\meta{keylist} of a keylist option is redefined to
  \meta{option}\keyname{+}|=|\meta{keylist}.  In other words, keylists behave additively by
  default.  The rationale is that one usually wants to add keys to a keylist.  The usual,
  non-additive behaviour can be accessed by \indexdef{suffix>augmented assignment=keylist>'=\meta{option}}|=|\meta{keylist}.

  Manipulating the keylist option using augmented assignments might have the side-effect of adding
  an empty key to the list.
  
\indexitem{type>dimen} contains a dimension.

  The value given to a dimension option is automatically evaluated by |pgfmath|.  In other words, 
  {\rstyle\meta{option}}|=|\meta{value} is implicitly understood as 
  \meta{option}|/|\index{pgfmath}|=|\meta{value}.

  For a \meta{dimen} option \meta{option}, the following additional keys (``augmented
  assignments'') are defined:
  \begin{syntax}
  \indexitem{suffix>augmented assignment=dimen>+=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()+|\meta{value}
  \indexitem{suffix>augmented assignment=dimen>-=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()-|\meta{value}
  \indexitem{suffix>augmented assignment=dimen>*=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()*|\meta{value}
  \indexitem{suffix>augmented assignment=dimen>:=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()/|\meta{value}
  \end{syntax}

  The evaluation of \meta{pgfmath} can be quite slow.  There are two tricks to speed things up
  \emph{if} the \meta{pgfmath} expression is simple, i.e.\ just a \TeX\ \meta{dimen}:
  \begin{enumerate}
  \item |pgfmath| evaluation of simple values can be sped up by prepending |+| to the value
    \citep[\S62.1]{tikzpgf2.10};
  \item use the key \indexdef{suffix>augmented assignment=dimen>'=\meta{option}}|=|\meta{value} to invoke a normal \TeX\ assignment.
  \end{enumerate}

  The two above-mentioned speed-up tricks work for the augmented assignments as well.  The keys for
  the second, \TeX-only trick are: \indexdef{suffix>augmented assignment=dimen>'+}, \indexdef{suffix>augmented assignment=dimen>'-}, \indexdef{suffix>augmented assignment=dimen>'*}, \indexdef{suffix>augmented assignment=dimen>':} --- note that for the latter two,
  the value should be an integer.

\indexitem{type>count} contains an integer.

  The additional keys and their behaviour are the same as for the \meta{dimen} options.%
  \indexdef[not print]{suffix>augmented assignment=count>+}%
  \indexdef[not print]{suffix>augmented assignment=count>-}%
  \indexdef[not print]{suffix>augmented assignment=count>*}%
  \indexdef[not print]{suffix>augmented assignment=count>:}%
  \indexdef[not print]{suffix>augmented assignment=count>'}%
  \indexdef[not print]{suffix>augmented assignment=count>'+}%
  \indexdef[not print]{suffix>augmented assignment=count>'-}%
  \indexdef[not print]{suffix>augmented assignment=count>'*}%
  \indexdef[not print]{suffix>augmented assignment=count>':}%

\indexitem{type>boolean} contains $0$ (false) or $1$ (true).

  In the general case, the value given to a \meta{boolean} option is automatically
  parsed by |pgfmath| (just as for \meta{count} and \meta{dimen}): if the computed value is
  non-zero, $1$ is stored; otherwise, $0$ is stored.  Note that |pgfmath| recognizes constants
  |true| and |false|, so it is possible to write \meta{option}|=true| and
  \meta{option}|=false|.

  If key \meta{option} is given no argument, pgfmath evaluation does not apply and a true value is
  set.  To quickly set a false value, use key \indexdef{word prefix=boolean option>>not=\meta{option}} (with no arguments). 
\end{syntax}

\subsubsection{Reading}
\label{sec:option-reading}

Option and register values can be accessed using the four macros listed below, handlers
\index{handler>option} and \index{handler>register} (\S\ref{ref:handlers}) and |pgfmath| functions
(\ref{ref:pgfmath}).

\begin{syntax}
  \indexitem{macro>forestoption}|{|\meta{option}|}|
  \itemnosep
  \indexitem{macro>foresteoption}|{|\meta{option}|}|
  \itemnosep
  \indexitem{macro>forestregister}|{|\meta{register}|}|
  \itemnosep
  \indexitem{macro>foresteregister}|{|\meta{register}|}|

  These macros expand to the value of the given option or register.  Note that
  \index{macro>forestoption} and \index{macro>foresteoption} expand to the value of the given option
  of the \emph{current node}; to access option values of a non-current node, use |pgfmath|
  functions.

  In the context of |\edef|, \cmdname{forestoption} and \cmdname{forestregister} expand precisely to
  the token list of the option value, while \cmdname{foresteoption} and \cmdname{foresteregister}
  fully expand the value.
  
  \begin{advise}
  \item These macros can be useful in \TeX\ code introduced by \index{TeX} or \PGF;'s handler
    |.expanded| \citep[\S55.4.6]{tikzpgf2.10}.
  \end{advise}
\end{syntax}


\subsubsection{Declaring}
\label{sec:option-declaring}

Using the following keys, users can also declare their own options and registers.  The new options
and registers will behave exactly like the predefined ones.

Note that the declaration of an option must provide a default value, while the declaration of a
register must not do that.  The default value of an option will be assigned to any newly created
nodes; the existing nodes are not affected.

\begin{syntax}
  \indexitem{node key>declare toks}|=|\meta{option name}\meta{default value}
  Declares a \meta{toks} option.

  \indexitem{node key>declare autowrapped toks}|=|\meta{option name}\meta{default value}
  Declares an \meta{autowrapped toks} option.

  \indexitem{node key>declare keylist}|=|\meta{option name}\meta{default value}
  Declares a \meta{keylist} option.

  \indexitem{node key>declare dimen}|=|\meta{option name}\meta{default value}
  Declares a \meta{dimen} option.

  \indexitem{node key>declare count}|=|\meta{option name}\meta{default value}
  Declares a \meta{count} option.

  \indexitem{node key>declare boolean}|=|\meta{option name}\meta{default value}
  Declares a \meta{boolean} option.
  
  \indexitem{node key>declare toks register}|=|\meta{register name}
  Declares a \meta{toks} register.

  \indexitem{node key>declare autowrapped toks register}|=|\meta{register name}
  Declares an \meta{autowrapped toks} register.
  
  \indexitem{node key>declare keylist register}|=|\meta{register name}
  Declares a \meta{keylist} register.
  
  \indexitem{node key>declare dimen register}|=|\meta{register name}
  Declares a \meta{dimen} register.
  
  \indexitem{node key>declare count register}|=|\meta{register name}
  Declares a \meta{count} register.

  \indexitem{node key>declare boolean register}|=|\meta{register name}
  Declares a \meta{boolean} register.
\end{syntax}

Several scratch registers are predefined:
\begin{syntax}
  \indexitem{register>temptoksa}, \indexdef{register>temptoksb}, \indexdef{register>temptoksc}, \indexdef{register>temptoksd}  Predefined \meta{toks} registers.

  \indexitem{register>tempkeylista}, \indexdef{register>tempkeylistb}, \indexdef{register>tempkeylistc}, \indexdef{register>tempkeylistd}  Predefined \meta{keylist} registers.

  \indexitem{register>tempdima}, \indexdef{register>tempdimb}, \indexdef{register>tempdimc}, \indexdef{register>tempdimd}, \indexdef{register>tempdimx}, \indexdef{register>tempdimy}, \indexdef{register>tempdiml}, \indexdef{register>tempdims}  Predefined \meta{dimen} registers.

  \indexitem{register>tempcounta}, \indexdef{register>tempcountb}, \indexdef{register>tempcountc}, \indexdef{register>tempcountd}  Predefined \meta{count} registers.

  \indexitem{register>tempboola}, \indexdef{register>tempboolb}, \indexdef{register>tempboolc}, \indexdef{register>tempboold}  Predefined \meta{boolean} registers.
\end{syntax}



\subsection{Formatting the tree}
\label{sec:formatting-tree}


\subsubsection{Node appearance}
\label{ref:node-appearance}

The following options apply at stage \index{typeset nodes}. Changing them
afterwards has no effect in the normal course of events. 

\begin{syntax}
\indexitem({{{{{}}}}}){option>align}|=|\index{value=align>left}\OR\index{value=align>center}\OR\index{value=align>right}\OR\meta{toks: tabular header}

  Creates a left/center/right-aligned multiline node, or a tabular node.  In the
  \index{content} option, the lines of the node should separated by |\\| and the columns (if
  any) by |&|, as usual.

  The vertical alignment of the multiline/tabular node can be specified by option \index{base}.

\begin{forestexample}[index={l sep,align,base}]
  \begin{forest} l sep+=2ex
    [special value&actual value\\\hline
      \indexdef{value=align>left}&||\texttt{@\{\}l@\{\}}\\
      \indexdef{value=align>center}&||\texttt{@\{\}c@\{\}}\\
      \indexdef{value=align>right}&||\texttt{@\{\}r@\{\}}\\
      ,~align~=ll,draw
      [top base\\right aligned, ~align~=right,~base~=top]
      [left aligned\\bottom base, ~align~=left,~base~=bottom]
    ]
  \end{forest}
\end{forestexample}

  Internally, setting this option has two effects:
  \begin{enumerate}
  \item The option value (a |tabular| environment header specification) is set.  The special
    values \keyname{left}, \keyname{center} and \keyname{right} invoke styles setting the actual
    header to the value shown in the above example.
    \begin{advise}
    \item If you know that the \keyname{align} was set with a special value, you can easily check
      the value using \index{if in toks option=\index{align}}.
    \end{advise}
  \item Option \index{content format} is set to the following value:
    \begin{lstlisting}
      \noexpand\begin{tabular}[\forestoption{base}]{\forestoption{align}}%
        \forestoption{content}%
      \noexpand\end{tabular}%
    \end{lstlisting}
    As you can see, it is this value that determines that options \keyname{base}, \keyname{align} and
    \keyname{content} specify the vertical alignment, header and content of the table.
  \end{enumerate}

\indexitem(t){option>base}|=|\meta{toks: vertical alignment}

This option controls the vertical alignment of multiline (and in general, \texttt{tabular}) nodes
created with \index{align}.  Its value becomes the optional argument to the \texttt{tabular}
environment.  Thus, sensible values are \indexdef{value=base>t} (the top line of the table will
be the baseline) and \indexdef{value=base>b} (the bottom line of the table will be the baseline).
Note that this will only have effect if the node is anchored on a baseline, like in the default
case of \index{option>anchor}|=base|.

For readability, you can use \indexdef{value=base>top} and \indexdef{value=base>bottom} instead
of \keyname{t} and \keyname{b}.  (\keyname{top} and \keyname{bottom} are still stored as
\keyname{t} and \keyname{b}.) 

  \indexitem({{{{{}}}}}){option>content}|=|\meta{autowrapped toks} The content of the node.

  Normally, the value of option \keyname{content} is given implicitely by virtue of the special
  (initial) position of content in the bracket representation (see~\S\ref{ref:bracket}).  However,
  the option also be set explicitely, as any other option.

\begin{forestexample}[index={for step,tree,if option,option>n,option>n'},point={content,delay},index={content,delay}]
  \begin{forest}
    delay={for tree={
        if n=1{content=L}
             {if n'=1{content=R}
                      {content=C}}}}
    [[[][][]][[][][]]]
  \end{forest}
\end{forestexample}
  Note that the execution of the \keyname{content} option should usually be delayed: otherwise, the
  implicitely given content (in the example below, the empty string) will override the explicitely
  given content.

\begin{forestexample}[index={for step,tree,if option,option>n,option>n',content},point={content}]
  \begin{forest}
    for tree={
        if n=1{content=L}
             {if n'=1{content=R}
                      {content=C}}}
    [[[][][]][[][][]]]
  \end{forest}
\end{forestexample}

  \indexitem(\forestoption{content}){option>content format}|=|\meta{toks}  

  When typesetting the node under the default conditions (see option \index{node format}), the
  value of this option is passed to the \TikZ; \texttt{node} operation as its \meta{text} argument
  \citep[\S16.2]{tikzpgf2.10}.  The default value of the option simply puts the content in the
  node.

  This is a fairly low level option, but sometimes you might still want to change its value.  If
  you do so, take care of what is expanded when.  Most importantly, if you use a formatting
  command such as |\textbf| in the default setting of \index{node format}, be sure to precede
  it with |\noexpand|. For details, read the documentation of option \index{node format} and
  macros \index{forestoption} and \index{foresteoption}; for an example, see option
  \index{align}.

\indexitem{node key>math content} Changes \index{content format} so that the content of the node
  will be typeset in a math environment.

\indexitem{node key>plain content}  Resets \index{content format} to the default value.

\indexitem{option>node format}|=|\meta{toks}
  \hfill|\noexpand\node(\forestoption{name})|\\
  \mbox{}\hfill|[\forestoption{node options}]{\foresteoption{content format}};|

  The node is typeset by executing the expansion of this option's value in a |tikzpicture|
  environment.

  Important: the value of this option is first expanded using |\edef| and only then executed. Note
  that in its default value, \index{content format} is fully expanded using
  \index{foresteoption}: this is necessary for complex content formats, such as |tabular|
  environments.

  This is a low level option.  Ideally, there should be no need to change its value.  If you do,
  note that the \TikZ; node you create should be named using the value of option \index{option>name};
  otherwise, parent--child edges can't be drawn, see option \index{edge path}. 

\indexitem{node key>node format'}|=|\meta{toks}

Sets \index{node format}, automatically wrapping the given \meta{toks} by
|\noexpand\node(\forestoption{name})| and |;|. Only the node options and content must therefore be
given.
  
\indexitem(anchor=base){option>node options}|=|\meta{keylist}

  When the node is being typeset under the default conditions (see option \index{node format}),
  the content of this option is passed to \TikZ; as options to the 
  \TikZ; |node| operation \citep[\S16]{tikzpgf2.10}.

  This option is rarely manipulated manually: almost all options unknown to \foRest; are
  automatically appended to \keyname{node options}.  Exceptions are (i) \index{label} and
  \index{pin}, which require special attention in order to work; and (ii) \index{option>anchor},
  which is saved in order to retain the information about the selected anchor.

\begin{forestexample}[index={for step,descendants,option>anchor,option>child anchor,option>parent anchor,grow,l sep,tree,propagator>where,delay,content,node options,pgfmath}]
  \begin{forest}
    for descendants={anchor=east,child anchor=east},
    grow=west,anchor=north,parent anchor=north,
    l sep=1cm,
    for tree={~fill=yellow~},where={n()<=3}{~draw=red~}{},
    delay={for tree={content/.pgfmath=~node_options~}}
    [root,rotate=90,
      [,~fill=white~]
      [,~node options'~]
      []
      []
      [,~node options~={~ellipse~}]
    ]
  \end{forest}
\end{forestexample} 

\indexitem(false){option>phantom}|=|\meta{boolean}

  A phantom node and its surrounding edges are taken into account when packing, but not
  drawn. (This option applies in stage \index{draw tree}.)
\begin{forestexample}[point=phantom,index={option>phantom}]
  \begin{forest}
    [VP[DP][V',phantom[V][DP]]]
  \end{forest}
\end{forestexample}

\end{syntax}



\subsubsection{Node position}
\label{ref:ref-node-position}

Most of the following options apply at stage \index{pack}. Changing them afterwards has no effect
in the normal course of events.  (Options \index{option>l}, \index{option>s}, \index{x}, \index{y} and
\index{option>anchor} are exceptions; see their documentation for details).

\begin{syntax}

  \indexitem(base){option>anchor}|=|\meta{toks: \foRest; anchor}

  While this option is saved by \foRest;, it is essentially an option of \TikZ;'s |\node| command
  \citep[see][\S16.5.1]{tikzpgf2.10}.  \FoRest; \index{autoforward}s it to keylist option
  \index{node options}, which is passed on to \TikZ;'s |\node| command when the node is typeset.
  (Option |anchor| thus normally applies in stage \index{typeset nodes}.)

  In the \TikZ; code, you can refer to the node's anchor using \FoRest;'s anchor
  \index{anchor>anchor}; this anchor is sometimes also called the node anchor in this
  documentation, to distinguish it clearly from parent and child anchors.

  \meta{toks: \foRest; anchor} can be any \TikZ; anchor.  Additionally, \FoRest; defines several
  tree hierarchy related anchors; for details, see \S\ref{sec:anchors}.

  The effect of setting the node anchor is twofold:
  \begin{itemize}
  \item during packing, the anchors of all siblings are \index{option>l}-aligned;
  \item some \index{calign} methods use node anchors (of the parent and/or certain children) to
    \index{option>s}-align the block of children to the parent.
  \end{itemize}

  \indexitem(center){option>calign}|=|\alternative{child,child edge,midpoint,edge midpoint,fixed
  angles,fixed edge angles}\\\alternative{first,last,center}.
  
  The packing algorithm positions the children so that they don't overlap, effectively computing
  the minimal distances between the node anchors of the children.  This option (\keyname{calign}
  stands for child alignment) specifies how the children are positioned
  with respect to the parent (while respecting the above-mentioned minimal distances).

  The child alignment methods refer to the primary and the secondary child, and to the primary and
  the secondary angle.  These are set using the keys described just after \keyname{calign}.

  \let\outerleftmargin\leftmargin
  \begin{syntax}
  \item\keyname{calign}|=|\indexdef{value=calign>child} s-aligns the node anchors of the parent and
    the primary child.
  \item\keyname{calign}|=|\indexdef{value=calign>child edge} s-aligns the parent anchor of the parent 
    and the child anchor of the primary child.
  \item \keyname{calign}|=|\indexdef{value=calign>first} is an abbreviation for
    |calign=child,calign_child=1|.
  \item \keyname{calign}|=|\indexdef{value=calign>last} is an abbreviation for
    |calign=child,calign_child=-1|.
  \item\keyname{calign}|=|\indexdef{value=calign>midpoint} s-aligns the parent's node anchor and the
    midpoint between the primary and the secondary child's node anchor.
  \item\keyname{calign}|=|\indexdef{value=calign>edge midpoint} s-aligns the parent's parent anchor
    and the midpoint between the primary and the secondary child's child anchor.
  \item \keyname{calign}|=|\indexdef{value=calign>center} is an abbreviation for\\
    |calign=midpoint,| |calign_primary_child=1,| |calign_secondary_child=-1|. 
\begin{forestexample}
  \begin{forest}
    [center,calign=center[1]
      [first,calign=first[A][B][C]][3][4][5][6]
      [last,calign=last[A][B][C]][8]]
  \end{forest}
\end{forestexample}
  \item\keyname{calign}|=|\indexdef{value=calign>fixed angles}: The angle between the direction of
  growth at the current node (specified by option \index{grow}) and the line through the node
  anchors of the parent and the primary/secondary child will equal the primary/secondary angle.

  To achieve this, the block of children might be spread or further distanced from the parent.
  \item\keyname{calign}|=|\indexdef{value=calign>fixed edge angles}: The angle between the direction of
  growth at the current node (specified by option \index{grow}) and the line through the
  parent's parent anchor and the primary/secondary child's child anchor will equal the
  primary/secondary angle.
  
  To achieve this, the block of children might be spread or further distanced from the parent.
\begin{forestexample}[point=calign,index={calign,fixed edge angles,calign primary angle,calign secondary angle,for step,tree,option>l},index>={!}]
  \begin{forest}
    calign=fixed edge angles,
    calign primary angle=-30,calign secondary angle=60,
    for tree={l=2cm}
    [CP[C][TP]]
    \draw[dotted] (!1) -| coordinate(p) () (!2) -| ();
    \path ()--(p) node[pos=0.4,left,inner sep=1pt]{-30};
    \path ()--(p) node[pos=0.1,right,inner sep=1pt]{60};
  \end{forest}
\end{forestexample}
  \end{syntax}
\indexitem{node key>calign child}|=|\meta{count} is an abbreviation for \index{calign primary
  child}|=|\meta{count}.
\indexitem(1){option>calign primary child}|=|\meta{count} Sets the primary child.  
  (See \index{calign}.)

  \meta{count} is the child's sequence number.  Negative numbers start counting at the last child.
\indexitem(-1){option>calign secondary child}|=|\meta{count} Sets the secondary child. 
  (See \index{calign}.)

  \meta{count} is the child's sequence number.  Negative numbers start counting at the last child.
\indexitem{node key>calign angle}|=|\meta{count} is an abbreviation for: \index{calign primary
  angle}|=-|\meta{count}, \index{calign secondary angle}|=|\meta{count}.
\indexitem(-35){option>calign primary angle}|=|\meta{count} Sets the primary angle.
  (See \index{calign}.) 
\indexitem(35){option>calign secondary angle}|=|\meta{count} Sets the secondary angle. 
  (See \index{calign}.)
\indexitem{node key>calign with current} s-aligns the node anchors of the current node and its
  parent.  This key is an abbreviation for:\indexex[not print]{wrap pgfmath arg,calign,child,calign primary child}
\begin{lstlisting}
  for parent/.wrap pgfmath arg={calign=child,calign primary child=##1}{n}.
\end{lstlisting}
\indexitem{node key>calign with current edge} s-aligns the child anchor of the current node and the
  parent anchor of its parent.  This key is an abbreviation for:\indexex[not print]{wrap pgfmath arg,calign,child edge,calign primary child}
\begin{lstlisting}
  for parent/.wrap pgfmath arg={calign=child edge,calign primary child=##1}{n}
\end{lstlisting}

  \indexitem(tight){option>fit}|=|\alternative{tight,rectangle,band}

\begin{forestexample}[layout=export,basicstyle=\footnotesize\ttfamily]
  \makeatletter\tikzset{use path/.code={\tikz@addmode{\pgfsyssoftpath@setcurrentpath#1}
    \appto\tikz@preactions{\let\tikz@actions@path#1}}}\makeatother
  \forestset{show boundary/.style={
    before drawing tree={get min s tree boundary=\minboundary, get max s tree boundary=\maxboundary},
    tikz+={\draw[red,use path=\minboundary]; \draw[red,use path=\maxboundary];}}}
\end{forestexample}
\input{\jobname.tmp}

This option sets the type of the (s-)boundary that will be computed for the subtree rooted in the
node, thereby determining how it will be packed into the subtree rooted in the node's parent.
There are three choices:\footnote{Below is the definition of style \keyname{show boundary}. The
\keyname{use path} trick is adjusted from \TeX\ Stackexchange question
\href{http://tex.stackexchange.com/questions/26382/calling-a-previously-named-path-in-tikz}{Calling
a previously named path in tikz}.

\box\codebox}
  \begin{itemize}
  \item\keyname{fit}|=|\indexdef{value=fit>tight}: an exact boundary of the node's subtree is computed,
    resulting in a compactly packed tree.  Below, the boundary of subtree L is drawn.
\begin{forestexample}[point={fit,tight},index={fit,{value=fit>tight},delay,for step,tree,option>name,content,pgfmath}]
  \begin{forest}
    delay={for tree={name/.pgfmath=content}}
    [root
      [L,fit=tight, % default
         show boundary
        [L1][L2][L3]]
      [R]
    ]
  \end{forest}
\end{forestexample}
\makeatletter\tikzset{use path/.code={%
  \tikz@addmode{\pgfsyssoftpath@setcurrentpath#1}%
  \appto\tikz@preactions{\let\tikz@actions@path#1}%
  }}\makeatother
\item\keyname{fit}|=|\indexdef{value=fit>rectangle}: puts the node's subtree in a rectangle and effectively
  packs this rectangle; the resulting tree will usually be wider.
\begin{forestexample}[point={fit,rectangle},index={fit,{value=fit>rectangle},delay,for step,tree,option>name,content,pgfmath}]
  \begin{forest}
    delay={for tree={name/.pgfmath=content}}
    [root
      [L,fit=rectangle,
         show boundary
        [L1][L2][L3]]
      [R]
    ]
  \end{forest}
\end{forestexample}
\item\keyname{fit}|=|\indexdef{value=fit>band}: puts the node's subtree in a rectangle of ``infinite
  depth'': the space under the node and its descendants will be kept clear.
\begin{forestexample}[point={fit,band},index={fit,{value=fit>band},delay,for step,tree,option>name,content,pgfmath}]
  \begin{forest}
    delay={for tree={name/.pgfmath=content}}
    [root
      [L[L1][L2][L3]]
      [C,fit=band]
      [R[R1][R2][R3]]
    ]
    \draw[thin,red]
      (C.south west)--(C.north west)
      (C.north east)--(C.south east);
    \draw[thin,red,dotted]
      (C.south west)--+(0,-1)
      (C.south east)--+(0,-1);
  \end{forest}
\end{forestexample}
  \end{itemize}

\indexitem(270){option>grow}|=|\meta{count}, \indexdef{node key>grow'}|=|\meta{count},
  \indexdef{node key>grow''}|=|\meta{count}

  The direction of the tree's growth at the node.

  The growth direction is understood as in \TikZ;'s tree library \citep[\S18.5.2]{tikzpgf2.10}
  when using the default growth method: the (node anchor's of the) children of the node are placed
  on a line orthogonal to the current direction of growth. (The final result might be different,
  however, if \index{option>l} is changed after packing or if some child undergoes tier alignment.)

  This option is essentially numeric (|pgfmath| function \keyname{grow} will always return an
  integer), but there are some twists.  The growth direction can be specified either numerically
  or as a compass direction (|east|, |north east|, \dots).  Furthermore, like in \TikZ;, setting
  the growth direction using key \keyname{grow} additionally sets the value of option
  \index{reversed} to |false|, while setting it with \keyname{grow'} sets it to |true|; to
  change the growth direction without influencing \index{reversed}, use key \index{grow''}.

  Between stages \index{pack} and \index{compute xy}, the value of \keyname{grow} should not
  be changed.

\begin{forestexample}[index={delay,where in toks option,content,for step,current,grow,grow',grow'',pgfmath}]
  \begin{forest}
    delay={where in content={~grow~}{
        for current/.pgfmath=content,
        content=\texttt{#1}
      }{}
    }
    [{~grow~=south}
      [{~grow'~=west}[1][2][3]
        [{~grow''~=90}[1][2][3]]]
      [2][3][4]
      [{~grow~=east}[1][2][3]
        [{~grow''~=90}[1][2][3]]]]
  \end{forest}
\end{forestexample}

\indexitem(false){option>ignore}|=|\meta{boolean}

If this option is set, the packing mechanism ignores the node, i.e.\ it pretends that the node has
no boundary. Note: this only applies to the node, not to the tree.

Maybe someone will even find this option useful for some reason \dots

\indexitem(false){option>ignore edge}|=|\meta{boolean}

If this option is set, the packing mechanism ignores the edge from the node to the parent, i.e.\
nodes and other edges can overlap it. (See \S\ref{sec:bugs} for some problematic situations.)

\begin{forestexample}[index={ignore edge,option>l,dimen*=l}]
  \begin{forest}
    [A[B[B][B][B][B]][C
      [\texttt{not ignore edge},l*=2]]]
  \end{forest}
  \begin{forest}
    [A[B[B][B][B][B]][C
      [\texttt{ignore edge},l*=2,~ignore edge~]]]
  \end{forest}
\end{forestexample}

\indexitem{option>l}|=|\meta{dimen} The l-position of the node, in the parent's ls-coordinate system.  (The
origin of a node's ls-coordinate system is at its (node) anchor.  The l-axis points in the
direction of the tree growth at the node, which is given by option \index{grow}. The s-axis is
orthogonal to the l-axis; the positive side is in the counter-clockwise direction from |l| axis.)

The initial value of \keyname{l} is set from the standard node.  By default, it equals:
\[\index{l sep}+2\cdot\mbox{\texttt{outer ysep}}+\mbox{total
height(standard node)}\]

The value of \keyname{l} can be changed at any point, with different effects.  
\begin{itemize}
\item The value of \keyname{l} at the beginning of stage \index{pack} determines the minimal
  l-distance between the anchors of the node and its parent.  Thus, changing \keyname{l} before
  packing will influence this process.  (During packing, \keyname{l} can be increased due to
  parent's \index{l sep}, tier alignment, or \index{calign} methods
  \index{fixed angles} and \index{fixed edge angles}.

\item Changing \keyname{l} after packing but before stage \index{compute xy} will result in a
  manual adjustment of the computed position.  (The augmented assignment operators can be useful here.)

\item Changing \keyname{l} after the absolute positions have been computed has no effect in the
  normal course of events.
\end{itemize}

\indexitem{option>l sep}|=|\meta{dimen} The minimal l-distance between the node and its
descendants.

This option determines the l-distance between the \emph{boundaries} of the node and its descendants,
not node anchors.  The final effect is that there will be a \keyname{l sep} wide band,
in the l-dimension, between the node and all its descendants.

The initial value of \keyname{l sep} is set from the standard node and equals
\[\mbox{height}(\mbox{strut})+\mbox{\texttt{inner ysep}}\]

Note that despite the similar name, the semantics of \keyname{l sep} and \keyname{s sep} are
quite different.

\indexitem(false){option>reversed}|=|\meta{boolean}

If |false|, the children are positioned around the node in the counter-clockwise direction; if
|true|, in the clockwise direction.  See also \index{grow}. 

\indexitem(0){option>rotate}|=|\meta{count}

This option is saved and \index{autoforward}ed to \TikZ;'s |\node| command via \index{node options}.

\indexitem{option>s}|=|\meta{dimen} The s-position of the node, in the parent's ls-coordinate system.
(The origin of a node's ls-coordinate system is at its (node) anchor.  The l-axis points in the
direction of the tree growth at the node, which is given by option \index{grow}.  The s-axis is
orthogonal to the l-axis; the positive side is in the counter-clockwise direction from |l| axis.)

The value of \keyname{s} is computed in stage \index{pack stage} and used in stage \index{compute xy
  stage}, so it only makes sense to (inspect and) change it in \index{before computing xy} and
during packing (\index{before packing node} and \index{after packing node}).  \emph{Any value given
  before packing is overridden, and changing the value after computing xy has no effect.}

For example, consider the manual correction below.  By default, B is closer to A than C because
packing proceeds from the first to the last child --- the position of B would be the same if there
was no C.  Adjusting \keyname{s} at the right moment, it is easy to center B between A and C.
\begin{forestexample}[tree bin=minipage,point=s,index={before computing xy,option>s}]
  \begin{forest}
    [no manual correction of B
      [A[1][2][3][4]]
      [B]
      [C[1][2][3][4]]
    ]
  \end{forest}
  
   \begin{forest}
    [manual correction of B
      [A[1][2][3][4]]
      [B,before computing xy={s/.average={s}{siblings}}]
      [C[1][2][3][4]]
    ]
  \end{forest}
\end{forestexample}

\indexitem{option>s sep}|=|\meta{dimen}

The subtrees rooted in the node's children will be kept at least \keyname{s sep} apart in the
s-dimension.  Note that \keyname{s sep} is about the minimal distance between node
\emph{boundaries}, not node anchors.

The initial value of \keyname{s sep} is set from the standard node and equals
$2\cdot\mbox{\texttt{inner xsep}}$. 

Note that despite the similar name, the semantics of \keyname{s sep} and \keyname{l sep} are
quite different.

\indexitem({{{{{}}}}}){option>tier}|=|\meta{toks}

Setting this option to something non-empty ``puts a node on a tier.''  All the nodes on the same
tier are aligned in the l-dimension.

Tier alignment across changes in growth direction is impossible.  In the case of incompatible
options, \foRest; will yield an error.

Tier alignment also does not work well with \index{calign}|=|\index{fixed angles} and \index{calign}|=|\index{fixed edge angles}, because these child alignment methods may change the
l-position of the children.  When this might happen, \foRest; will yield a warning.

\indexitem{option>x}=\meta{dimen}
\vspace{-\parskip}
\indexitem{option>y}=\meta{dimen}

\keyname{x} and \keyname{y} are the coordinates of the node in the ``normal'' (paper) coordinate
system, relative to the root of the tree that is being drawn.  So, essentially, they are absolute
coordinates.

The values of \keyname{x} and \keyname{y} are computed in stage \index{compute xy}.  It only
makes sense to inspect and change them (for manual adjustments) afterwards (normally, in the
\index{before drawing tree} hook, see \S\ref{ref:stages}.)  \keyname{x} and \keyname{y} of the
(formal) root node are exceptions, as they are not changed in stage \index{compute xy}.
\begin{forestexample}[label=ex:adjustxy,index={y,dimen-,grow',option>l,for step,tree,before drawing tree}]
  \begin{forest}
    for tree={grow'=45,l=1.5cm}
    [A[B][C][D,before drawing tree={~y-~=4mm}[1][2][3][4][5]][E][F]]
  \end{forest}
\end{forestexample}

\end{syntax}

\subsubsection{Edges}
\label{ref:ref-edge}

These options determine the shape and position of the edge from a node to its parent.  They apply
at stage \index{draw tree}.

\begin{syntax}
\indexitem({{{{{}}}}}){option>child anchor}|=|\meta{toks: \foRest; anchor} See \index{option>parent anchor}.

\indexitem(draw){option>edge}|=|\meta{keylist}

  When \index{edge path} has its default value, the value of this option is passed as options to
  the \TikZ; |\path| expression used to draw the edge between the node and its parent.

  Also see key \index{no edge}.

\begin{forestexample}[point=edge,index={edge,no edge,for step,tree,grow',option>l,option>anchor,option>child anchor}]
  \begin{forest} for tree={grow'=0,l=2cm,anchor=west,child anchor=west},
    [root
      [normal]
      [none,~no~ edge]
      [dotted,edge=dotted]
      [dashed,edge=dashed]
      [dashed,edge={dashed,red}]
    ]
  \end{forest}
\end{forestexample}

\indexitem({{{{{}}}}}){option>edge label}|=|\meta{toks: \TikZ; code}

When \index{edge path} has its default value, the value of this option is used at the end of
the edge path specification to typeset a node (or nodes) along the edge.

The packing mechanism is not sensitive to edge labels.

\begin{forestexample}[index={edge label}]
  \begin{forest}
    [VP
      [V,~edge label~={node[midway,left,font=\scriptsize]{head}}]
      [DP,~edge label~={node[midway,right,font=\scriptsize]{complement}}]
    ]
  \end{forest}
\end{forestexample}

\indexitem{option>edge path}|=|\meta{toks: \TikZ; code}
 \hfill |\noexpand\path[|\index{forestoption}|{|\index{edge}|}]|\\
 \mbox{}\hfill |(|\index>{!}|u.|\index{anchor>parent anchor}|)--(.|\index{anchor>child anchor}|)|\index{forestoption}|{|\index{edge label}|};|

This option contains the code that draws the edge from the node to its parent.  By default, it
creates a path consisting of a single line segment between the node's \index{option>child anchor} and
its parent's \index{option>parent anchor}. Options given by \index{edge} are passed to the path; by
default, the path is simply drawn.  Contents of \index{edge label} are used to potentially place
a node (or nodes) along the edge.

When specifying the edge path, the values of options \index{edge} and \index{edge label} can be
used.  Furthermore, two anchors, \index{anchor>parent anchor} and \index{anchor>child anchor}, are defined, 
to facilitate access to options \index{option>parent anchor} and \index{option>child anchor} from the \TikZ; code.

The node positioning algorithm is sensitive to edges, i.e.\ it will avoid a node overlapping an
edge or two edges overlapping. However, the positioning algorithm always behaves as if the
\keyname{edge path} had the default value --- \emph{changing the \keyname{edge path} does not
influence the packing!}  Sorry.  (Parent--child edges can be ignored, however: see option
\index{ignore edge}.)

\indexitem{node key>edge path'}|=|\meta{toks: \TikZ; code}

Sets \index{edge path}, automatically wrapping the given path by
|\noexpand\path[\forestoption{edge}]| and |\forestoption{edge label};|.

\indexitem({{{{{}}}}}){option>parent anchor}|=|\meta{toks: \foRest; anchor} (Information also applies to
option \index{option>child anchor}.)

\FoRest; defines anchors \index{anchor>parent anchor} and
\index{anchor>child anchor} (which work only for \foRest; and not also \TikZ;
nodes, of course) to facilitate reference to the desired endpoints of child--parent edges.
Whenever one of these anchors is invoked, it looks up the value of the \keyname{parent anchor} or
\keyname{child anchor} of the node named in the coordinate specification, and forwards the request
to the (\TikZ;) anchor given as the value.

The intended use of the two anchors is chiefly in \index{edge path} specification, but they can
used in any \TikZ; code.
\begin{forestexample}[index={anchor>parent anchor,anchor>child anchor,for step,tree},index>={!}]
  \begin{forest}
    for tree={~parent anchor~=south,~child anchor~=north}
    [VP[V][DP]]
    \path[fill=red] (.parent anchor) circle[radius=2pt]
                    (!1.child anchor) circle[radius=2pt]
                    (!2.child anchor) circle[radius=2pt];
  \end{forest}
\end{forestexample}

The empty value (which is the default) is interpreted as in \TikZ;: as an edge to the appropriate
border point.  See also \S\ref{sec:anchors} for a list of additional anchors defined by \foRest;.

\indexitem{node key>no edge} Clears the edge options (\index{edge}|'={}|) and sets \index{ignore
edge}.

\end{syntax}

\subsubsection{Information about node}
\label{ref:node-info}
\label{ref:readonly-options}

The values of these options provide various information about the tree and its nodes.

\begin{syntax}
\indexitem{node key>alias}|=|\meta{toks} 
\itemnosep
\indexitem{node key>alias'}|=|\meta{toks} Sets the alias for the node's name.

  Unlike \index{option>name}, \keyname{alias} is \emph{not} an option: you cannot e.g.\ query it's
  value via a |pgfmath| expression.

  If the given alias clashes with an existing node name, |alias| will yield an error, while |alias'|
  will silently rename the node with this name to its default (|node@|\meta{id}) value.  Use an
  empty argument to reset the node's name to its default value.

  Aliases can be used as the \meta{forest node name} part of a relative node name and as the
  argument to the \index{step>name} step of a node walk.  The latter includes the usage
  as the argument of the \index{for step=\index{step>name}} propagator.

  Technically speaking, \foRest; alias is \emph{not} a \TikZ; alias!  However, you can still use
  it as a ``node name'' in \TikZ; coordinates, since \foRest; hacks \TikZ;'s implicit node
  coordinate system to accept relative node names; see \S\ref{ref:forest-cs}.
  
\indexitem{readonly option>id}|=|\meta{count} The internal id of the node.

\indexitem{readonly option>level}|=|\meta{count}  The hierarchical level of the node.  The root is on level $0$. 

\indexitem{readonly option>max x}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{readonly option>max y}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{readonly option>min x}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{readonly option>min y}|=|\meta{dimen}
  Measures of the node, in the shape's coordinate system
  \citep[see][\S16.2,\S48,\S75]{tikzpgf2.10} shifted so that the node anchor is at the origin.

  In |pgfmath| expressions, these options are accessible as |max__x|, |max__y|, |min__x| and |min__y|.

\indexitem{readonly option>n}|=|\meta{count}  The child's sequence number in the list of its parent's
  children. 

  The enumeration starts with 1.  For a geometric root, \keyname{n} equals $0$. 

\indexitem{readonly option>n'}|=|\meta{count}  Like \index{option>n}, but starts counting at the last child.

  In |pgfmath| expressions, this option is accessible as |n__|.

\indexitem(node@\meta{id}){option>name}|=|\meta{toks} 
\itemnosep
\indexitem{node key>name'}|=|\meta{toks} Sets the name of the node.

The expansion of \meta{toks} becomes the \meta{forest node name} of the node.  The \TikZ; node
created from the \foRest; node will get the name specified by this option.

Node names must be unique.  If a node with the given name already exists, |name| will yield an
error, while |name'| will silently rename the node with this name to its default (|node@|\meta{id})
value.  Use an empty argument to reset the node's name to its default value.

  
\indexitem{readonly option>n children}|=|\meta{count} The number of children of the node.
  
  In |pgfmath| expressions, this option is accessible as |n__children|.
\end{syntax}

  
\subsubsection{Various}

\begin{syntax}
\indexitem{node key>baseline} The node's anchor becomes the baseline of the whole tree
  \citep[cf.][\S69.3.1]{tikzpgf2.10}.

  In plain language, when the tree is inserted in your (normal \TeX) text, it will be vertically
  aligned to the anchor of the current node.

  Behind the scenes, this style sets the alias of the current node to \keyname{forest@baseline@node}.
\begin{forestexample}[index={baseline,use as bounding box'}]
  {\tikzexternaldisable
  Baseline at the
  \begin{forest}
    [parent,~baseline~,use as bounding box'
      [child]]
  \end{forest}
  and baseline at the
  \begin{forest}
    [parent
      [child,~baseline~,use as bounding box']]
  \end{forest}.}
\end{forestexample}

\indexitem(\begin{tikzpicture}){node key>begin draw}|/.code=|\meta{toks: \TeX\ code}  \vspace{-\parskip}
\indexitem(\end{tikzpicture}){node key>end draw}|/.code=|\meta{toks: \TeX\ code}

The code produced by \index{draw tree} is put in the environment specified by \keyname{begin
draw} and \keyname{end draw}.  Thus, it is this environment, normally a |tikzpicture|, that does
the actual drawing.

A common use of these keys might be to enclose the |tikzpicture| environment in a |center|
environment, thereby automatically centering all trees; or, to provide the \TikZ; code to execute
at the beginning and/or end of the picture.

Note that \keyname{begin draw} and \keyname{end draw} are \emph{not} node options: they are
|\pgfkeys|' code-storing keys \citep[\S55.4.3--4]{tikzpgf2.10}.

\indexitem>{tikz key>fit to}|=|\meta{nodewalk} Fits the \TikZ; node to the nodes in the given
  \meta{nodewalk}.

This key should be used like \keyname{/tikz/fit} of the \TikZ;'s fitting library
\citep[see][\S34]{tikzpgf2.10}: as an option to \emph{\TikZ;'s} |node| operation, the obvious
restriction being that \keyname{fit to} must be used in the context of some \foRest; node.
For an example, see footnote~\ref{fn:fit-to-tree}.

This key works by calling \keyname{/tikz/fit} and providing it with the the coordinates of the
subtree's boundary.

The \meta{nodewalk} inherits its history from the outer nodewalk (if there is one).  Its every-step
keylist is empty.

\indexitem{node key>get min s tree boundary}|=|\meta{cs} \vspace{-\parskip}
\indexitem{node key>get max s tree boundary}|=|\meta{cs}

Puts the boundary computed during the packing process into the given \meta{cs}.  The boundary is
in the form of \PGF; path.  The |min| and |max| versions give the two sides of the node.  For an
example, see how the boundaries in the discussion of \index{fit} were drawn.

\indexitem{option>label}|=|\meta{toks: \TikZ; node}  The current node is labelled by a \TikZ; node.

  The label is specified as a \TikZ; option \texttt{label} \citep[\S16.10]{tikzpgf2.10}.
  Technically, the value of this option is passed to \TikZ;'s as a late option
  \citep[\S16.14]{tikzpgf2.10}.  (This is so because \foRest; must first typeset the nodes
  separately to measure them (stage \index{typeset nodes}); the preconstructed nodes are inserted
  in the big picture later, at stage \index{draw tree}.)  Another option with the same
  technicality is \index{pin}. 
  
\indexitem{option>pin}|=|\meta{toks: \TikZ; node}  The current node gets a pin, see
  \citep[\S16.10]{tikzpgf2.10}. 
¸
  The technical details are the same as for \index{label}.


\indexitem{node key>use as bounding box} The current node's box is used as a bounding box for the
  whole tree.

  \indexitem{node key>use as bounding box'} Like \index{use as bounding box}, but subtracts the
  (current) inner and outer sep from the node's box.  For an example, see \index{baseline}.
  
  \indexitem({{{{{}}}}}){option>tikz}|=|\meta{toks: \TikZ; code}  ``Decorations.''

  The code given as the value of this option will be included in the |tikzpicture| environment
  used to draw the tree.  The code given to various nodes is appended in a depth-first,
  parent-first fashion.  The code is included after all nodes of the tree have been drawn, so it
  can refer to any node of the tree.  Furthermore, relative node names can be used to refer to
  nodes of the tree, see \S\ref{ref:relative-node-names}.

  By default, bracket parser's afterthoughts feed the value of this option.  See
  \index{afterthought}. 
  
\end{syntax}  



\subsection{Nodewalks}
\label{ref:nodewalks}

A \emph{nodewalk} is a sequence of \emph{steps} describing a path through the tree.  Most steps
are defined relative to the current node, for example \index{step>parent} steps to the parent of the
current node, and \index{step>n}|=2| steps to the second child of the current node, where ``to make a
step'' means to change the current node.  Thus, nodewalk |parent,_parent,_n=2| describes the path
which first steps to the parent of the \emph{origin} node, then to its grandparent and finally to
the second child of the origin's grandparent.

The origin of the nodewalk depends on how the nodewalk is invoked.  When used after the \index>{!} in a
relative node name (\S\ref{ref:relative-node-names}), the origin is the node with the name given
before \index>{!}; when invoked by a spatial propagator such as \index{for step=\index{nodewalk}}
(\S\ref{ref:spatial-propagators}), the origin is the current node.

Formally, a \meta{nodewalk} is a list of |pgfkeys| key--value pairs.  Steps in a nodewalk are thus
separated by commas.  However, \foRest; also recognizes \emph{short-form} steps, whose names consist
of a single character and which do not need to be separated by a comma.  For example, nodewalk
|parent,_parent,_n=2| can be concisely written as |uu2|.  Long and short forms can be mixed freely,
like this: |next,_uu2,_previous|.

Besides nodewalk keys, a \meta{nodewalk} can also contain node keys (or
even \TikZ; keys).\footnote{The precise algorithm for keyname resulotion in nodewalks is as follows.
\begin{itemize}
\item First, \foRest; searches for the given \meta{keyname} in the \index{path>forest/nodewalk}
  path.  If found (a long-form step or a nodewalk style), it is executed.
\item Next, it is checked whether \meta{keyname} is a sequence of short-form steps; is so, they are
  executed.
\item Otherwise, \meta{key} is executed in the \keyname{/forest} path.  This includes both
  \foRest;'s and \TikZ;'s keys.  The latter are usually forwarded to \TikZ; via \index{node
    options}.
\end{itemize}
There are some clashes between node key and nodewalk step names. For example, \keyname{l} is both a
\meta{dimen} option and a short form of the step to the last child. According to the rules above,
the nodewalk step will take precedence in case of a clash. Use nodewalk key \index{options} to
execute a clashing node key.} These keys do their usual function, but within the context of the
current node of the nodewalk: |parent, s=2em,| |parent, text=red| sets the parent's |s| to 2em and
the grandparent's text color to red.  It is worth noting that node keys include \index{TeX}, which
makes it possible to execute any \TeX\ code while nodewalking.

Some steps target a single node, like above-mentioned \index{step>parent} and \index{step>n}.
Others, called multi-steps, describe mini-walks themselves: for example \index{step>children} visits
each child of the node in turn, and \index{tree} visits each of the node's descendants (including
the node itself).  The path of many steps is determined by the geometric relations of the tree, or
the value of some option.  However, there are also keys for embedding nodewalks (\index{nodewalk
  key>nodewalk}, \index{branch}, etc.), saving and loading nodewalks, sorting them, or even
re-walking the history of steps made (like in a web browser).\footnote{Note that nesting operation
  (\S\ref{ref:nodewalk-operations}) and history (\S\ref{ref:nodewalk-history}) steps, or embedding
  nodewalks under these steps doesn't work, for most combinations, as many of them internally
  manipulate nodewalk history.} Finally, if all this is not enough, you can define your own steps,
see \S\ref{ref:defining-steps}.

Each nodewalk has an associated \emph{every-step keylist}: a keylist of node keys\footnote{When
  executing the \index{register>every step} keylist, \foRest; switches into the
  \index{path>forest} path, which makes it impossible to directly include a nodewalk into the
  every-step keylist.  The reason is performance.  Every time a \index{path>forest/nodewalk} key
  is not found, the short-form nodewalk recognition algorithm is executed, and this algorithm is
  slow.  As \index{register>every step} is used a lot (it is for example used every invocation of
  every spatial propagator) and the keys in \index{register>every step} are usually node options
  from \index{path>forest} path, \foRest; would spend way too much time checking if a given node
  option is actually a short-form nodewalk.

  If you need to execute nodewalk keys within the every-step keylist, use node key
  \index{node key>Nodewalk}.} which get executed after each step of the nodewalk.  The every-step
keylist of the current nodewalk is contained in register \index{register>every step} and can be
changed at any point during the nodewalk.  Its value at the start of the nodewalk depends on how the
nodewalk was invoked.  In most cases (e.g.\ \index{step>nodewalk} or prefix
\index{for step}-based spatial propagators), it is given explicitely as an argument to the key
that executes the nodewalk.  However, see \index{step>Nodewalk} for information on how the
every-step keylist of an embedded nodewalk can interact with the every-step keylist of its parent
nodewalk.

Each nodewalk step can be either \emph{real} or \emph{fake}.  Fake steps only change the current
node.  Real steps also trigger execution of the every-step keylist and update of history.  Fake
steps are sometimes useful as a ``computational tool''.  They can be introduced explicitely using
\index{nodewalk key>fake}; some other keys (like some history nodewalk keys, \S\ref{ref:nodewalk-history})
introduce fake steps implicitely.

In some cases, the nodewalk might step ``out of the tree''.  (Imagine using \index{step>parent} at the
root of the tree, or \index{option>n}|=42| at a node with less that 42 children.)  Our official term will
be that the nodewalk stepped on an \emph{invalid node}; what happens formally is that the current
node is changed to the node with \index{option>id}|=0|.  Normally, such an event raises an
error.  However, the full story is told by \index{nodewalk key>on invalid}.

Nodewalks can be hard to follow, especially when designing styles. \FoRest; does its best to
help. First, it logs the nodewalk stack in case of error.  Second, if package option
\index{debug} is given, it logs every step made.


\subsubsection{Single-step keys}
\label{ref:single-step-keys}

Single-step nodewalk keys visit a single node.  If the node a single-step is trying to visit does
not exist, the current node is set to the invalid node (i.e.\ node with \index{option>id}|=0|).  This
can be useful for looping, see \S\ref{ref:loops}.  Use \index{last valid} or \index{last valid'}
to return to the node that was current before the ``unsuccessful'' single-step.

For each single-step key, propagator \index{for step=\meta{step}} is also defined.
\index{for step=\meta{step}}|=|\meta{keylist} is equivalent to
\index{propagator>for}|={|\meta{step}|}{|\meta{keylist}|}|.  If the step takes an argument, then its
\index{for step=\meta{step}} propagator takes two and the argument of the step precedes the
\meta{keylist}.  See also \S\ref{ref:spatial-propagators}.

Linear order below means the order of nodes in the bracket representation, i.e.\ depth-first
parent-first first-child-first.

\begin{syntax}
\indexitem{step>current} an ``empty'' step: the current node remains the same\footnote{While it
  might at first sight seem stupid to have an empty step, this is not the case.  For example,
  using propagator \index{for step=\index{current}} derived from this step, one can process a \meta{keylist} constructed using \index[not index,print format+={result+={\index[not print]{wrap pgfmath arg}\index[not print]{wrap $n$ pgfmath args}}}]{handler>wrap ($n$) pgfmath arg(s)} or \index{wrap value}.}
\indexitem{step>first} the first child
\indexitem{step>first leaf}, \indexdef{step>first leaf'} the first leaf (terminal node) of the
  current node's descendants (|first leaf|) or subtree (|first leaf'|), in the linear order
\indexitem{step>id}|=|\meta{id} the node with the given id; this step does not depend on the current node
\indexitem{step>last} the last child
\indexitem{step>last leaf}, \indexdef{step>last leaf'} the last leaf (terminal node) of the
  current node's descendants (|last leaf|) or subtree (|last leaf'|), in the linear order
\indexitem{step>n}|=|$n$ the $n$th child; counting starts at $1$\footnote{Note that \keyname{n}
  \emph{without} an argument is a short form of \keyname{next}.}
\indexitem{step>n'}|=|$n$ the $n$th child, starting the count from the last child
\indexitem{step>name}|=|\meta{name} the node with the given name or alias; this step does not depend on the current node
\indexitem{step>next} the next sibling 
\indexitem{step>next leaf} the next node (in the linear order) which is a leaf (the current node need not be a leaf) 
\indexitem{step>next node} the next node of the entire tree, in the linear order 
\indexitem{step>next on tier}|=|\meta{tier} the next node (in the linear order) on the given tier; if no tier is given, assume the tier of the current node  
\indexitem{step>origin} the starting node of the nodewalk; note that the starting point does not automatically count as a step: if you want to step on it, use this key (or \index{current}, at the beginning of the nodewalk)
\indexitem{step>parent} the parent 
\indexitem{step>previous} the previous sibling 
\indexitem{step>previous leaf} the previous node (in the linear order) which is a leaf (the current node need not be a leaf) 
\indexitem{step>previous node} the previous node of the entire tree, in the linear order 
\indexitem{step>previous on tier}|=|\meta{tier} the previous node (in the linear order) on the given tier; if no tier is given, assume the tier of the current node
\indexitem{step>root} the root node, i.e.\ the ancestor of the current node without the parent; note that this key \emph{does} depend on the current node
\indexitem{step>root'} the formal root node (see \index{set root} in \S\ref{ref:dynamic}); this key does not depend on the current node
\indexitem{step>sibling} the sibling

(don't use if the parent doesn't have exactly two children \dots)
\indexitem{step>to tier}|=|\meta{tier} the first ancestor of the current node (or the node itself) on the given \meta{tier}
\end{syntax}


\subsubsection{Multi-step keys}
\label{ref:multi-step-keys}

Multi-step keys visit several nodes, in general. If a multi-step key visits no nodes, the current
node remains unchanged.

For each multi-step key, spatial propagator \index{for step=\meta{step}} is also defined, see
\S\ref{ref:spatial-propagators}.

Many of the keys below have a |reversed| variant.  Those keys reverse the order of \emph{children}.
Note that in general, this differs from operation key \index{reverse}, which reverses the order of
the entire embedded nodewalk.

Linear order below means the order of nodes in the bracket representation, i.e.\ depth-first
parent-first first-child-first.

\begin{syntax}
  \indexitem{step>children}, \indexdef{step>children reversed}

  Visit all the children of the current
  node.

\indexitem{step>tree}, \indexdef{step>tree reversed}
  \itemnosep
\indexitem{step>tree children-first}, \indexdef{step>tree children-first reversed}
  \itemnosep
\indexitem{step>tree breadth-first}, \indexdef{step>tree breadth-first reversed}
  
  Visit the current node and all its descendants.

  The above keys differ in the order the nodes are visited.  The basic key, \keyname{tree},
  traverses the nodes in the depth-first, parent-first first-child-first order, i.e.\ the order in
  which they are given in the bracket representation: so it visits the parent before its children and
  it visits the children from the first to the last.

  |reversed| variants reverse the order of \emph{children}, visiting them from the last to the first
  (from the viewpoint of the bracket representation).

  |children-first| variants visit the children before the parent.

  |breadth-first| variants behave like |level| steps below: they first visit level |0| nodes, then
  level |1| nodes etc.

  \begin{forestexample}[index={}]
    \forestset{
      enumerate/.style={
        tempcounta=1,
        for #1={
          content/.pgfmath=tempcounta,
          tempcounta+=1
        }
      }
    }
    \newcommand\enumtree[1]{%
      \begin{forest}
        [#1,l sep=0,for n=1{
          l=0,no edge,delay={enumerate=#1}}
          [[[[][]][[][]]][[[][]]]]
        ]
      \end{forest}
    }
    \renewcommand\arraystretch{2}
    \begin{tabular}{cc}
      \enumtree{tree}&
      \enumtree{tree reversed}\\
      \enumtree{tree children-first}&
      \enumtree{tree children-first reversed}\\
      \enumtree{tree breadth-first}&
      \enumtree{tree breadth-first reversed}
    \end{tabular}    
  \end{forestexample}
  
\indexitem{step>descendants}, \indexdef{step>descendants reversed}
  \itemnosep
\indexitem{step>descendants children-first}, \indexdef{step>descendants children-first reversed}
  \itemnosep
\indexitem{step>descendants breadth-first}, \indexdef{step>descendants breadth-first reversed}
  
  Visit all the descendants of the current node.

  Like the |tree| keys, but the current node is not visited.

\indexitem[print form+=\spaces{9}]{step>relative level <},
  \indexdef[print form+=\spaces{9}]{step>relative level},
  \indexdef[set={form=relative level \protect\greaterthan}]{step>relative level GT}\texttt{\spaces{9}}|=|\meta{count}
  \itemnosep
\indexitem{step>relative level reversed <},
  \indexdef{step>relative level reversed},
  \indexdef[set={form=relative level reversed \protect\greaterthan}]{step>relative level reversed GT}|=|\meta{count}
  \itemnosep
\indexitem[print form+=\spaces{9},+print form=\spaces{9}]{step>level <},
  \indexdef[print form+=\spaces{9},+print form=\spaces{9}]{step>level},
  \indexdef[set={form=level \protect\greaterthan},+print form=\spaces{9}]{step>level GT}\texttt{\spaces{9}}|=|\meta{count}
  \itemnosep
\indexitem[+print form=\spaces{9}]{step>level reversed <},
  \indexdef[+print form=\spaces{9}]{step>level reversed},
  \indexdef[set={form=level reversed \protect\greaterthan},+print form=\spaces{9}]{step>level reversed GT}|=|\meta{count}

  Visits the nodes in the subtree of the current node whose level (depth) is less than \emph{or
    equal to}, equal to, or greater than \emph{or equal to} the given level.

  The |relative| variants consider the level as relative to the current node: relative level of the
  current node is $0$; relative level of its children is $1$, of its grandchildren $2$, etc.  The
  absolute variants consider the depth with respect to the (geometric) root, i.e.\ as returned by
  node option \index{option>level}.

  The nodes are traversed in the breadth-first order.  The |reversed| variants reverse the order of
  the children within each level, but the levels are still traversed from the highest to the
  deepest.

\indexitem[+print form=\spaces{12},print form+=\spaces{9}]{step>preceding siblings}\quad\quad
  \indexdef[+print form=\spaces{12}]{step>following siblings}%
  \itemnosep
\indexitem[print form+=\spaces{9}]{step>current and preceding siblings}\quad\quad
  \indexdef{step>current and following siblings}%
  \itemnosep
\indexitem[+print form=\spaces{12}]{step>preceding siblings reversed}\quad\quad
  \indexdef[+print form=\spaces{12}]{step>following siblings reversed}%
  \itemnosep
\indexitem{step>current and preceding siblings reversed}\quad\quad
  \indexdef{step>current and following siblings reversed}%
  \itemnosep
\indexitem[+print form=\spaces{22},print form+=\spaces{9}]{step>siblings}%
  \itemnosep
\indexitem[print form={current and \spaces{9} siblings\spaces{9}}]{step>current and siblings}%
  \itemnosep
\indexitem[+print form=\spaces{22},print form+=\spaces{9}]{step>siblings reversed}%
  \itemnosep
\indexitem[print form={current and \spaces{13} siblings reversed}]{step>current and siblings reversed}%

Visit preceding, following or all siblings; visit the current node as well or not; visit in normal
or reversed order.

\indexitem{step>ancestors}
  \itemnosep
\indexitem{step>current and ancestors}
  
Visit the ancestors of the current node, starting from the parent/current node, ending at the root node.

\indexitem[+print form=\spaces{12}]{step>preceding nodes}\quad\quad
  \indexdef[+print form=\spaces{12}]{step>following nodes}%
  \itemnosep
\indexitem{step>current and preceding nodes}\quad\quad
  \indexdef{step>current and following nodes}%

Visit all preceding or following nodes of the entire tree, in the linear order; visit the current node as well or not.
  
\end{syntax}

\subsubsection{Embedded nodewalks}
\label{ref:embedded-walks}

An embedded nodewalk is a nodewalk within a nodewalk.  The embedded nodewalk has its own every-step
keylist.  While stepping through the inner nodewalk, the every-step keylist of the outer nodewalk is
not executed.  Modifying the every-step keylist of the inner walk (by \index{register>every step}) does not
influence the outer nodewalk.

After the embedded nodewalk finished, its final current node becomes the current node of the outer
nodewalk.  This is true even if the final node was reached by a fake step.

\begin{advise}
\item As node keys can be used within nodewalks, one can use spatial propagators
  (\S\ref{ref:spatial-propagators}) like \index{for step=\index{step>nodewalk}} to embed a nodewalk
  which (silently) returns to the current node of the outer nodewalk.
\end{advise}

An embedded nodewalk does not count as a step of the outer nodewalk (except if noted otherwise, see
\index{group}).  This means that the every-step keylist of the outer nodewalk is not executed at
the final node of the embedded nodewalk.  In other words, the step made by the embedded nodewalk as
a unit is fake.

Embedded nodewalks also have their own origin and history.  Nodewalks can be nested to an arbitrary
level.

\begin{syntax}
\indexitem{step>Nodewalk}|=|\meta{keylist: config}\meta{nodewalk}\meta{keylist: every-step}

  Walks an (embedded) \meta{nodewalk} starting at the current node.

  From the perspective of the outer nodewalk, the embedded nodewalk is an (implicitely) fake step
  (and cannot be made real by \index{real}): the last node visited by the embedded
  \meta{nodewalk} becomes the new current node of the outer nodewalk, even if it is invalid.

  The \meta{config} argument serves to specify the interaction between the outer and embedded
  nodewalk.  It can contain the following keys:

  \let\outerleftmargin\leftmargin
  \begin{syntax}
    \indexitem(independent){option of=Nodewalk>every step}|={|\alternative{independent,inherited,shared}|}|
    \indexitem(shared){option of=Nodewalk>history}|={|\alternative{independent,inherited,shared}|}|

    The following table shows what happens to the every-step keylist and history depending on the
    value of \keyname{every step} and \keyname{history}, respectively.  State B is \meta{every-step}
    for every step and empty for history.
      
      \begin{tabular}{l|ccc}
        &\keyname{independent}&\keyname{inherited}&\keyname{shared}\\\hline
        state of the outer nodewalk&A&A&A\\
        initial state of the inner nodewalk&B&A&A\\
        \dots\\
        final state of the inner nodewalk&C&C&C\\
        state of the outer nodewalk&A&A&C
      \end{tabular}      
  \end{syntax}

  As shown in the table above, argument \meta{every-step} is used to initialize the
  embedded nodewalk's every-step keylist when it is independent of the outer nodewalk.  In other
  cases, this argument is ignored (use |{}|).

  \begin{syntax}
    \indexitem(inherited){option of=Nodewalk>on invalid}|={|\alternative{error,fake,step,inherited}|}|

    Like \index{nodewalk key>on invalid}, but local to this nodewalk.  The additional alternative
    \indexdef{value=on invalid>inherited} (which is the default) means to behave as specified by
    \index{nodewalk key>on invalid} (or the package default, \index{value=on invalid>error}, if no
    \index{nodewalk key>on invalid} was given).
  \end{syntax}
  

\begin{forestexample}
  \begin{forest}
    for 2=calign with current, for children={for descendants={circle,draw}}
    [every step,
      [independent,for nodewalk={
        1,Nodewalk={~every step=independent~}{1,every step=fill,1}{},1}{draw=red},
        [[[[]]]]]
      [inherited,for nodewalk={
        1,Nodewalk={~every step=inherited~}{1,every step=fill,1}{},1}{draw=red},
        [[[[]]]]]
      [shared,for nodewalk={
        1,Nodewalk={~every step=shared~}{1,every step=fill,1}{},1}{draw=red},
        [[[[]]]]]]
  \end{forest}
\end{forestexample}


\begin{forestexample}
  \begin{forest}
    mark/.style={tempcounta+=1,content+/.register=tempcounta,content+={,}},
    [history:\\effect on the,align=center
      [inner nodewalk
        % uncommenting this would result in an error:
        % [independent, delay={for nodewalk={
        %     tempcounta=0,111,
        %     Nodewalk={history=independent}{walk back=2}{mark,fill=yellow}
        %   }{mark,draw=red}},
        %   [[[]]]]
        [inherited\\or\\shared, align=center,delay={for nodewalk={
              tempcounta=0,111,
              Nodewalk={~history=inherited~}{walk back=2}{mark,fill=yellow}
            }{mark,draw=red}},
          [[[]]]]]
      [outer nodewalk
        [inherited,delay={for nodewalk={
            tempcounta=0,111,
            Nodewalk={~history=inherited~}{11}{mark,fill=yellow},
            walk back=2
          }{mark,draw=red}},
          [[[[[]]]]]]
        [shared,delay={for nodewalk={
            tempcounta=0,111,
            Nodewalk={~history=shared~}{11}{mark,fill=yellow},
            walk back=2
          }{mark,draw=red}},
          [[[[[]]]]]]]]
  \end{forest}
\end{forestexample}
  
  
\indexitem{step>nodewalk}|=|\meta{nodewalk}\meta{keylist: every-step}

  This key is a shorthand for

  \begin{center}
    \index{step>Nodewalk}|={|\index{option of=Nodewalk>every step}|=independent,|\index{option of=Nodewalk>history}|=independent}|\meta{nodewalk}\meta{keylist: every-step}
  \end{center}

  \begin{advise}
  \item  \index{for step=\index{nodewalk}} is also defined.
  \end{advise}
  
\indexitem{step>nodewalk'}|=|\meta{nodewalk}

  This key is a shorthand for

  \begin{center}
    \index{step>Nodewalk}|={|\index{option of=Nodewalk>every step}|=inherited,|\index{option of=Nodewalk>history}|=independent}|\meta{nodewalk}\meta{keylist: every-step}
  \end{center}
  
  \begin{advise}
  \item  \index{for step=\index{nodewalk'}} is also defined.
  \end{advise}
  
\indexitem{step>group}|=|\meta{nodewalk}

  Treat \meta{nodewalk} as a single step of the (outer) nodewalk, i.e.\ the outer every-step keylist
  is executed only at the end of the embedded nodewalk.  The embedded \meta{nodewalk} inherits
  history from the outer nodewalk.  Using this key is equivalent to writing
  \begin{center}
    \index{step>Nodewalk}|={|\index{option of=Nodewalk>every step}|=independent,|\index{option
        of=Nodewalk>history}|=inherited}|\meta{nodewalk}|{}, current|
  \end{center}

  \begin{advise}
  \item It is safe to modify the every-step keylist of \meta{nodewalk}.
  \item \index{for step=\index{group}} is also defined.
  \end{advise}
  
\indexitem{nodewalk key>filter}|=|\meta{nodewalk}\meta{pgfmath: condition}

  Executes the every-step keylist of the outer nodewalk for every step in the inner \meta{nodewalk}
  after which the given pgfmath condition is true.

  This is the definition of |filter|:
\begin{lstlisting}
  filter/.style 2 args={% #1 = nodewalk, #2 = condition
    nodewalk/.expanded={\unexpanded{#1}}{if={\unexpanded{#2}}{\forestnodewalkeverystep}{}}
  },
\end{lstlisting}
  
  \begin{advise}
  \item Do not change the every-step keylist of the (inner) \meta{nodewalk}: added keys will get
    executed at every further step of the \meta{nodewalk}, regardless whether condition applies or
    not.
  \end{advise}

\indexitem{nodewalk key>branch}|={|\meta{nodewalk$_1$}|,...,|\meta{nodewalk$_n$}|}|
  \itemnosep
\indexitem{nodewalk key>branch'}|={|\meta{nodewalk$_1$}|,...,|\meta{nodewalk$_n$}|}|

  A ``cartesian product'' of any number of nodewalks.  At every step of \meta{nodewalk$_i$}, \meta{nodewalk$_{i+1}$} is executed.

  Both variants inherit the \index{register>every step} keylist of the containing nodewalk.  More precisely, in the |branch'| variant this keylist is executed for every step at every level, while in the |branch| variant,  this keylist is executed only for the innermost steps.

  \begin{advise}
  \item It is safe to add keys to the every-step keylist of the embedded nodewalks, but not to
    remove them, as this will impair the functionality of |branch|.  In other words, only use
    \index{+keylist=\index{register>every step}} and \index{keylist+=\index{register>every step}} inside
    \meta{nodewalk$_i$}.
  \end{advise}
  
  For an example, see \index{c-commanded}.
  
\end{syntax}

\subsubsection{Operations}
\label{ref:nodewalk-operations}

Most of the following keys have a |walk_and_...| variant, which first walks the given nodewalk and
then performs the desired operation.  All operation keys except |..._in_nodewalk| variants can be prefixed by \index{for step}.

\begin{syntax}
  \indexitem{step>reverse}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and reverse}|=|\meta{nodewalk}

  Visits the nodes of the given \meta{nodewalk} in the reversed order. 

  \indexitem{nodewalk key>save}|=|\meta{toks: name}\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and save}|=|\meta{toks: name}\meta{nodewalk}

  Saves the given \meta{nodewalk} under the given name. 
  
  \indexitem{step>load}|=|\meta{toks: name} Walks the nodewalk saved under the given name.  

  Note that it is node \index{option>id}s that are saved: loading a named nodewalk with in a context of
  a different current node, or even with a tree whose geometry has changed (see \S\ref{ref:dynamic})
  will still visit exactly the nodes that were visited when the nodewalk was saved.

  \indexitem{step>sort}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>sort'}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and sort}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and sort'}|=|\meta{nodewalk}

    Walks the nodes of the nodewalk in the order specified by the last invokation of \index{sort
      by}.  The \keyname{sort} variants sort in the ascending order, the \keyname{sort'} variants in
    the descending order.  The \keyname{walk and sort} variants first visit the nodes in the order
    specified by the given \meta{nodewalk}.

  \indexitem{node key>sort by}|={|\meta{pgfmath}|,|\dots|,|\meta{pgfmath}|}|

    Sets the sorting order used by all keys comparing nodes: \index{step>sort}, \index{step>min}
    and \index{step>max} key families in the nodewalk namespace, and the \index{dynamic
      tree>sort} key family in the option namespace (dynamic tree).
    
  For each node being ordered, an ``$n$-dimensional coordinate'' is computed by evaluating the given
  list of |pgfmath| expressions in the context of that node.\footnote{Don't worry, lazy evaluation
    is used.}  Nodes are then ordered by the usual sort order for multi-dimensional arrays: the
  first item is the most important, the second item is the second most important, etc.

  Simply put, if you want to sort first by the number of children and then by content, say
  |sort_by={|\index[+print format=pgfmath]{n children}|,_|\index{content}|}|.

  In the simplest case, the given \meta{pgfmath} expressions are simply node options.  However, as
  any |pgfmath| expression is allowed in the sort key, you can easily sort by the product of the
  content of the current node and the content of its first child:
  |sort_by={|\index{content}|()*|\index{content}|("|\index>{!}|1")|.  Note, however, that the value returned by these expression
    must be numeric, i.e.\ alphabetic comparison of strings is not implemented.


\indexitem{step>min}|=|\meta{nodewalk}, \indexdef{step>max}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and min}|=|\meta{nodewalk}, \indexdef{step>walk and max}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>mins}|=|\meta{nodewalk}, \indexdef{step>maxs}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and mins}|=|\meta{nodewalk}, \indexdef{step>walk and maxs}|=|\meta{nodewalk}


  Visit the node(s) in the given \meta{nodewalk} with a minimum/maximum value with
  respect to the sort order previously specified by \index{sort by}.  

  Variants \keyname{mins}/\keyname{maxs} visit all the nodes that with the minimum/maximum value of
  the sorting key; variants \keyname{min}/\keyname{max} visit only the first such node (first in the order specified by the given nodewalk).

  \indexitem{step>min in nodewalk}, \indexdef{step>max in nodewalk}
  \itemnosep
  \indexitem{step>mins in nodewalk}, \indexdef{step>maxs in nodewalk}
  \itemnosep
  \indexitem{step>min in nodewalk'}, \indexdef{step>max in nodewalk'}

  These keys search for the minimum/maximum among the nodes that were already visited in the current
  nodewalk.

  Keys \keyname{mins in nodewalk} and \keyname{maxs in nodewalk} visits all nodes that reach the minimum/maximum, while keys \keyname{min in nodewalk} and \keyname{max in nodewalk} variants visit only the first such node.

  Keys \keyname{min in nodewalk'} and \keyname{max in nodewalk'} visit the first minimal/maximal
  node by moving back in the history, see \index{back}.
\end{syntax}

\subsubsection{History}
\label{ref:nodewalk-history}

\FoRest; keeps track of nodes visited in a nodewalk and makes it possible to revisit them, in a
fashion similar to clicking the back and forward button in a web browser.

These keys cannot be prefixed by \index{for step}.

\begin{syntax}
  \indexitem{step>back}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>jump back}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>walk back}|=|\meta{count: n}

    Move $n$ steps back in the history. In the \keyname{back} variant, all steps are fake; in
    the \keyname{jump back} variant, the final step is real; and in the \keyname{walk back} variant,
    all steps are real.

    Note that as the origin is not a part of the history, these keys will \emph{not} step there
    (unless \index{current} was the first step of your nodewalk).  (Use \index{origin} to move
    to the origin of the nodewalk.)

  \indexitem{step>forward}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>jump forward}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>walk forward}|=|\meta{count: n}
    
    Move $n$ steps forward in the history. In the \keyname{forward} variant, all steps are fake; in
    the \keyname{jump forward} variant, the final step is real; and in the \keyname{walk forward} variant,
    all steps are real.

\indexitem{node key>save history}|=|\meta{toks: back name}\meta{toks: forward name}

Saves the backwards and forwards history under the given names. (Load them using \index{load}.)  The
backwards history is saved in the reverse order of how it was walked, i.e.\ outward from the
perspective of the current position in the nodewalk.
\end{syntax}


\subsubsection{Miscellaneous}
\label{ref:nodewalk-miscellaneous}

The following nodewalk keys are not steps. Rather, they influence the behaviour of nodewalk steps in
various ways.  The keys in this section having \meta{nodewalk} arguments do not start a new nodewalk
in the sense of \S\ref{ref:embedded-walks}; the given nodewalk steps rather become a part of the
current nodewalk.

\begin{syntax}
\indexitem{register>every step}|=|\meta{keylist} Contains the every-step keylist of the current
  nodewalk.
  
\indexitem{nodewalk key>fake}|=|\meta{nodewalk}
  \itemnosep
\indexitem{nodewalk key>real}|=|\meta{nodewalk}

  The \meta{nodewalk} embedded under |fake| consists of ``fake'' steps: while
  the current node is changed, every-step keylist is not executed and the history is not updated.
  
  Note that these keys do not introduce an embedded nodewalk.  The given \meta{nodewalk} will not
  have its own history and every-step keylist.

  |real| undoes the effect of |fake|, but cannot make real the implicitely fake steps, such as the
  return to the origin in spatial propagators like \index{for step=\index{nodewalk}}.
  |fake| and |real| can be nested without limit.

\indexitem{step>last valid}
  \itemnosep
\indexitem{step>last valid'}

  If the current node is valid, these keys do nothing.  If the current node of the nodewalk is
  invalid (i.e.\ its \index{option>id} is $0$), they step to the last valid visited node.  If
  there was no such node, they step to the origin of the nodewalk.

  The variant \emph{without} |'| makes a fake step. More precisely, it behaves as if both
  \index{nodewalk key>fake} and \index{nodewalk key>on invalid}|=fake| are in effect.

\indexitem(error){nodewalk key>on invalid}|={|\alternative{error,fake,step}|}|\meta{nodewalk}

  This key determines what should happen if a nodewalk step landed on the invalid node, i.e.\ the node
  with \index{option>id}|=0|.
  
  There is a moment within the step when the current node is changed but the step itself is not yet
  really done, is ``still fake'', i.e.\ the history is not yet updated and the every-step keylist is
  not yet executed.  If the new current node is invalid, this key determines what should happen next.

  \let\outerleftmargin\leftmargin
  \begin{syntax}
  \item |on invalid=|\indexdef{value=on invalid>error} produces an error;
  \item |on invalid=|\indexdef{value=on invalid>fake} does nothing: history is not updated and the
    every-step keylist is not executed, thus making the step essentialy fake;
  \item |on invalid=|\indexdef{value=on invalid>step} makes a step, either real or fake, depending
    on the environment.
  \end{syntax}

  Loops with the implicit |id=0| condition (\S\ref{ref:loops}) automatically switch to
  |on_invalid=fake| mode.
  
\indexitem{nodewalk key>options}=\meta{keylist: node keys}

  Execute the given node options in the context of the current node.

  There is not much need to use this key, as any keys that are not (long) steps or sequences of
  short steps are automatically used as \foRest; node options any way, but there are still usage
  cases, for example whenever the names of node options and (long) steps are the same, or in a style
  that wants to ensure there is no overlap.

\indexitem{nodewalk key>strip fake steps}|=|\meta{nodewalk}

  If \meta{nodewalk} ends with fake steps, return to the last node current before those steps were made.  For details, see \index{define long step}.

\end{syntax}


\subsubsection{Short-form steps}
\label{ref:short-form-steps}

All short forms of steps are one token long.  When using them, there is no need to separate them by
commas.  Here's the list of predefined short steps and their corresponding long-form steps.

\begin{syntax}
\indexitem{short step>1}, \indexdef{short step>2}, \indexdef{short step>3}, \indexdef{short step>4}, \indexdef{short step>5}, \indexdef{short step>6}, \indexdef{short step>7}, \indexdef{short step>8}, \indexdef{short step>9} the first, \dots, ninth child --- \index{option>n}|=1|,\dots,|,9|
\indexitem{short step>l} the last child --- \index{step>last}
\indexitem{short step>u} the parent (up) --- \index{step>parent}
\indexitem{short step>p} the previous sibling --- \index{previous}
\indexitem{short step>n} the next sibling --- \index{next}
\indexitem{short step>s} the sibling --- \index{sibling}
\indexitem{short step>P} the previous leaf --- \index{previous leaf}
\indexitem{short step>N} the next leaf --- \index{next leaf}
\indexitem{short step>F} the first leaf --- \index{first leaf}
\indexitem{short step>L} the last leaf --- \index{last leaf}
\indexitem[set={index key={<GT},form=\protect\greaterthan}]{short step>GT}
  the next node on the current tier --- \index{next on tier}
\indexitem{short step><} the previous node on the current tier --- \index{previous on tier}
\indexitem{short step>c} the current node --- \index{current}
\indexitem{short step>o} the origin --- \index{origin}
\indexitem{short step>r} the root node --- \index{root}
\indexitem{short step>R} the formal root node --- \index{root'}
\indexitem{short step>b} back one fake step in history --- \index{back}|=1|
\indexitem{short step>f} forward one fake step in history --- \index{forward}|=1|
\indexitem{short step>v} last valid node in the current nodewalk, fake version --- \index{last valid}
\indexitem{short step>*}\meta{count: n}\meta{keylist} repeat keylist $n$ times --- \index{repeat}|=|\meta{count: n}\meta{keylist}
\item {\rstyle $\{$}\meta{keylist}{\rstyle $\}$} put keylist in a group --- \index{group}|=|\meta{keylist}
\end{syntax}

\subsubsection{Defining steps}
\label{ref:defining-steps}

You can define your own steps, both long and short, or even redefine predefined steps.  Note,
though, that it is not advisable to redefine long steps, as their definitions are interdependent;
redefining short steps is always ok, however, as they are never used in the code of the package.

\begin{syntax}
\indexitem{node key>define long step}|=|\meta{name}\meta{options}\meta{nodewalk}

  Define a long-form step named \meta{name} as equivalent to \meta{nodewalk}.  \meta{options} control the exact behaviour or the defined step.
  
  \let\outerleftmargin\leftmargin
  \begin{syntax}
  \item\indexdef{option of=define long step>n args}|=|\meta{number}\hfill |1|
  \item\indexdef{option of=define long step>make for}|=|\meta{boolean}\hfill |true|
    
    Should we make a \index{for step} prefix for the step? 
  \item\indexdef{option of=define long step>strip fake steps}|=|\meta{boolean}\hfill |true|
    
    Imagine that \meta{nodewalk} ends with fake steps.  Now, fake steps are usually just a computational tool, so we normally wouldn't want the current node after the walk to be one of them. As far as the outer world is concerned, we want the node to end at the last real step. However, simply appending \index{last valid} to our style will not work.  Imagine that the nodewalk results in no steps.  In this case, we'd want to remain at the origin of our empty nodewalk.  However, imagine further that the (outer) step just before the empty nodewalk was fake.  Then \index{last valid} will not step to the correct node: instead of staying at the origin, it will go to the node that the last real step prior to our nodewalk stepped to.  In case there was no such real step, we'd even step to the invalid node (normally getting an error).

    Defining the step using |strip fake steps| ensures the correct behaviour described
    above.  Set |strip fake steps=false| only when the fake steps at the end of the nodewalk at
    important to you.

    \begin{advise}
      \item See also nodewalk key \index{nodewalk key>strip fake steps}.
    \end{advise}

  \end{syntax}

\begin{forestexample}[index={define long step,option of=define long step>n args,conditional>if,step>n,while,option>n,next}]
  \forestset{
    ~define long step~={children from to}{n args=2}{
      if={#1>#2}{}{n=#1,while={n()<#2}{next}}
    }
  }
  \begin{forest}
    for children from to={2}{5}{draw}
    [root[1][2][3][4][5][6]]
  \end{forest}
\end{forestexample}

  
\indexitem{node key>define short step}|=|\meta{token: short step}\meta{n args}\meta{nodewalk}

Define short step taking $n$ arguments as the given \meta{nodewalk}.  Refer to the arguments in the usual way, via |#1|, \dots.

To (re)define braces, |{}|, write |define short step={group}{1}{...}|.
\end{syntax}


\subsection{Conditionals and loops}
\label{ref:conditionals}
\label{ref:loops}

All conditionals take arguments \meta{true keylist} and \meta{false keylist}, and all loops take an
argument \meta{keylist}.  The interpretation of the keys in these keylists depends on the
environment the conditional/loop appears in.  If it is a part of a nodewalk
specification, the keys are taken to be nodewalk keys (\S\ref{ref:nodewalks}), otherwise node keys
(\S\ref{ref:node-keys}).

All the loops and conditionals can be nested safely.

\begin{advise}
\item Except in special circumstances, you probably don't want to embed keys from the \index{where
    option} family within a \index{for step=\index{tree}}, as this results in two nested loops. It
  is more usual to use an \index{conditional>if} family key there.  For an example where using
  \index{where option} actually does the wrong thing, see question
  \href{http://tex.stackexchange.com/questions/167978/smaller-roofs-for-forest}{Smaller roofs for
    forest} on \TeX\ Stackexchange.
\end{advise}

\begin{syntax}
\indexitem{conditional>if}|=|\meta{pgfmath condition}\meta{true keylist}\meta{false keylist}

  If \meta{pgfmath condition} evaluates to |true| (non-zero), \meta{true keylist} is processed (in
  the context of the current node); otherwise, \meta{false keylist} is processed.

  For a detailed description of |pgfmath| expressions, see \cite[part VI]{tikzpgf2.10}.  (In short:
  write the usual mathematical expressions.)

\indexitem{word prefix=option>conditional>if=\meta{option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}

  A simple conditional is defined for every \meta{option}: if \meta{value} equals the value of the
  option at the current node, \meta{true keylist} is executed; otherwise, \meta{false keylist}.

\indexitem{word prefix=boolean option>conditional>if=\meta{boolean option}}|=|\meta{true keylist}\meta{false keylist}

  Execute \meta{true keylist} if \meta{boolean option} is true; otherwise, execute \meta{false
    keylist}.

\indexitem{word prefix=toks option>conditional>if in=\meta{toks option}}|=|\meta{toks}\meta{true keylist}\meta{false
  keylist}

  Checks if \meta{toks} occurs in the option value; if it does, \meta{true keylist} are executed,
  otherwise \meta{false keylist}.

  This conditional is defined only for \meta{toks} options, see \S\ref{sec:option-setting}.
  
\indexitem{conditional>if nodewalk valid}|=|\meta{keylist: test nodewalk}\meta{true keylist}\meta{false keylist}

  If the test nodewalk finished on a valid node, \meta{true keylist} is processed (in the context of
  the current node); otherwise, \meta{false keylist} is processed.

\indexitem{conditional>if nodewalk empty}|=|\meta{keylist: test nodewalk}\meta{true keylist}\meta{false keylist}

  If the test nodewalk contains no (real) steps, \meta{true keylist} is processed (in the context of
  the current node); otherwise, \meta{false keylist} is processed.

\indexitem{conditional>if in saved nodewalk}|=|\meta{nodewalk}\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}

If the node at the end of \meta{nodewalk} occurs in the saved nodewalk, \meta{true keylist} is
processed (in the context of the current node); otherwise, \meta{false keylist} is processed.

\indexitem{propagator>if have delayed}|=|\meta{true keylist}\meta{false keylist}  If any options were
  delayed in the current cycle (more precisely, up to the point of the execution of this key),
  process \meta{true keylist}, otherwise process \meta{false keylist}.  (\index{delay n} will
  trigger ``true'' for the intermediate cycles.)

  This key assumes that the processing order of the innermost invocation of \index{process
    keylist} or \index{process keylist'} is given by \index{processing order}.  If this is not
  the case, explicitely supply the processing order using \index{if have delayed'}.

\indexitem{propagator>if have delayed'}|=|\meta{nodewalk}\meta{true keylist}\meta{false keylist}
  Like \index{if have delayed}, but assume the processing order given by \meta{nodewalk}.

\indexitem{propagator>where}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{word prefix=option>conditional>where=\meta{option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{word prefix=toks option>conditional>where in=\meta{toks option}}|=|\meta{toks}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{step>where nodewalk valid}|=|\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}
\itemnosep  
\indexitem{step>where nodewalk empty}|=|\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{step>where in saved nodewalk}|=|\meta{nodewalk}\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}

These keys execute their corresponding |if ...| conditional for every node in the subtree of the current node (including the node itself).  In other words:

\begin{center}
  |where ...|\meta{arg$_1$}\dots\meta{arg$_1$}|/.style={for tree={if ...=|\meta{arg$_1$}\dots\meta{arg$_1$}|}}|
\end{center}

\indexitem{loop>repeat}|=|\meta{number}\meta{keylist}

  The \meta{keylist} is processed \meta{number} times.

  The \meta{number} expression is evaluated using |pgfmath|.  

\indexitem{loop>while}|=|\meta{pgfmath condition}\meta{keylist}
  \itemnosep
\indexitem{loop>do while}|=|\meta{pgfmath condition}\meta{keylist}
  \itemnosep
\indexitem{loop>until}|=|\meta{pgfmath condition}\meta{keylist}
  \itemnosep
\indexitem{loop>do until}|=|\meta{pgfmath condition}\meta{keylist}

  \keyname{while} loops cycle while the condition is true, \keyname{until} loops terminate when the
  condition becomes true.

  The \keyname{do} variants check the condition after processing the \meta{keylist}; thus, the
  keylist is executed at least once.  The variants without the \keyname{do} prefix check the
  condition before processing the \meta{keylist}, which might therefore not be processed at all.

  When \meta{pgfmath condition} is an empty string, condition \index{valid} is implicitely used,
  and \meta{keylist} is implicitely embedded in \index{nodewalk key>on invalid}|=fake|.  Thus, the |while|
  loops will cycle until they ``walk out of the tree'', and |until| loops will cycle until they
  ``walk into the tree.''

  \begin{advise}
  \item If a loop ``walks out of the tree'', you can get it back in using \index{last valid} or
    \index{nodewalk key>strip fake steps}.
  \end{advise}

  
\begin{forestexample}[index={root',content,step>n,delay,for step,nodewalk,do until}]
  \pgfmathsetseed{1234}
  \begin{forest}
    try/.style={root',content+={#1,\ },n=#1},
    delay={
      for nodewalk={~do until~={}{try/.pgfmath={random(1,20)}},draw}{},
    },
    [tried:\ [1][2][3][4][5]]
  \end{forest}
\end{forestexample}

\indexitem{loop>while nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do while nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>until nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do until nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>while nodewalk empty}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do while nodewalk empty}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>until nodewalk empty}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do until nodewalk empty}|=|\meta{nodewalk}\meta{keylist}

  \meta{nodewalk} is embedded within \index{nodewalk key>on invalid}|=fake|.


\indexitem(0){loop>break}|=|$n$  Break out of the loop.

  The loop is only exited after all the keys in the current cycle have been processed.

  The optional argument $n$ ($n\geq0$) specifies which level of embedding to break from; the default
  is to break out of the innermost loop.
  
\end{syntax}


\subsection{Dynamic tree}
\label{ref:dynamic}

The following keys can be used to change the geometry of the tree by creating new nodes and
integrating them into the tree, moving and copying nodes around the tree, and removing nodes from
the tree.

The \meta{node} that will be (re)integrated into the tree can be specified in the following ways:
\begin{syntax}
\item \meta{empty}: uses the last non-integrated (i.e.\ created/removed/replaced) node.
\item \meta{node}: a new node is created using the given bracket representation (the node may
  contain children, i.e.\ a tree may be specified), and used as the argument to the key.

  The bracket representation must be enclosed in brackets, which will usually be enclosed in
  braces to prevent them being parsed while parsing the ``host tree.''
  \begin{advise}
  \item Unlike the bracket representation in a \index{environment>forest} environment, the bracket
    representation of a dynamically created node \emph{must} start with |[|. Specifically, it cannot
    begin with a preamble or the action character.
  \end{advise}
\item \index{relative node name}: the node \meta{relative node name} resolves to will be used.
\end{syntax}

A dynamic tree operation is made in two steps:
\begin{itemize}
\item If the argument is given by a \meta{node} argument, the new node is created immediately,
  i.e.\ while the dynamic tree key is being processed.  Any options of the new node are
  implicitely \index{delay}ed. 
\item The requested changes in the tree structure are actually made between the cycles of keylist
  processing.
\end{itemize}

\begin{advise}
\item Such a two-stage approach is employed because changing the tree structure during the dynamic
  tree key processing would lead to an unmanageable order of keylist processing.
\item A consequence of this approach is that nested dynamic tree keys take several cycles to
  complete.  Therefore, be careful when using \index{delay} and dynamic tree keys
  simultaneously: in such a case, it is often safer to use \index{before typesetting nodes}
  instead of \index{delay}, see example (\ref{ex:append}).
\item Examples: title page (in style |random tree|) and (\ref{ex:niceemptynodes}) (in style
  |xlist|).
\end{advise}

Here is the list of dynamic tree keys:

\begin{syntax}
\indexitem{dynamic tree>append}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new final child of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\begin{forestexample}[label=ex:append,point=append,index={append,delay,for step,tree,option>n,content,option>n',repeat}]
  \begin{forest}
    before typesetting nodes={for tree={
      if n=1{content=L}
           {if n'=1{content=R}
                    {content=C}}}}
    [,repeat=2{append={[
      ,repeat=3{append={[]}}
    ]}}]
  \end{forest}
\end{forestexample}

\indexitem{dynamic tree>create}|=[|\meta{node}|]|

Create a new node. The new node becomes the last node.

\indexitem{dynamic tree>create'}|=[|\meta{node}|]|

Create a new node and process its given options immediately.  The new node becomes the last node.

\indexitem{dynamic tree>insert after}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new following sibling of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\indexitem{dynamic tree>insert before}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new previous sibling of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\indexitem{dynamic tree>prepend}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new first child of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\indexitem{dynamic tree>remove}

The current node is removed from the tree and becomes the last node.

The node itself is not deleted: it is just not integrated in the tree anymore.  Removing the root
node has no effect.

\indexitem{dynamic tree>replace by}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The current node is replaced by the specified node.  The current node becomes the last node.

  If the specified node is a new node containing a dynamic tree key, it can refer to the replaced
  node by the \meta{empty} specification.  This works even if multiple replacements are made.
  
  If \keyname{replace by} is used on the root node, the ``replacement'' becomes the root node
  (\index{set root} is used). 

\end{syntax}

If given an existing node, most of the above keys \emph{move} this node
(and its subtree, of course).  Below are the versions of these operations which rather \emph{copy}
the node: either the whole subtree (|'|) or just the node itself (|''|).
\begin{syntax}
\indexitem{dynamic tree>append'}, \indexdef{dynamic tree>insert after'}, \indexdef{dynamic tree>insert before'}, \indexdef{dynamic tree>prepend'},
  \indexdef{dynamic tree>replace by'}

  Same as versions without |'| (also the same arguments), but it is the copy of the specified node
  and its subtree that is integrated in the new place.
\indexitem{dynamic tree>append''}, \indexdef{dynamic tree>insert after''}, \indexdef{dynamic tree>insert before''}, \indexdef{dynamic tree>prepend''},
  \indexdef{dynamic tree>replace by''}

  Same as versions without |''| (also the same arguments), but it is the copy of the specified node
  (without its subtree) that is integrated in the new place.

\begin{advise}
\item You might want to \index{delay} the processing of the copying operations, giving the
  original nodes the chance to process their keys first!
\end{advise}

\indexitem{dynamic tree>copy name template}|=|\meta{empty}\OR\meta{macro definition} \hfill\meta{empty}

Defines a template for constructing the \index{option>name} of the copy from the name of the
original.  \meta{macro definition} should be either empty (then, the \index{option>name} is
constructed from the \index{option>id}, as usual), or an expandable macro taking one argument (the
name of the original).

\begin{forestexample}
  \begin{forest}
    copy name template={copy of #1}
    [CP,delay={prepend'=subject}
      [VP[DP,name=subject[D][NP]][V'[V][DP]]]]
    \draw[->,dotted] (subject)--(copy of subject);
  \end{forest}
\end{forestexample}

\indexitem{dynamic tree>set root}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

The specified node becomes the new \emph{formal} root of the tree.

Note: If the specified node has a parent, it is \emph{not} removed from it.  The node becomes the
root only in the sense that the default implementation of stage-processing will consider it a
root, and thus typeset/pack/draw the (sub)tree rooted in this root.  The processing of keys such
as \index{for step=\index{step>parent}} and \index{for step=\index{root}} is not affected: \index{for step=\index{root}} finds the
real, geometric root of the current node.  To access the formal root, use nodewalk step
\index{root'}, or the corresponding propagator \index{for step=\index{root'}}.

\indexitem{dynamic tree>sort}, \indexdef{dynamic tree>sort'} Sort the children of the current node,
  using the currently active sort key specified in \index{sort by} (see
  \S\ref{ref:nodewalk-operations}).  |sort| sorts in ascending and |sort'| in descending order.

\end{syntax}


\subsection{Handlers}
\label{ref:handlers}

\begin{syntax}
\indexitem{handler>option}|=|\meta{option}

The result is the value of \meta{option} at the current node.

\indexitem{handler>register}|=|\meta{register}

The result is the value of \meta{register}.

\indexitem{handler>pgfmath}|=|\meta{pgfmath expression}

The result is the evaluation of \meta{pgfmath expression} in the context of the current node.

\begin{advise}
\item 
  If you only need to access an option or register value, using \index{handler>option} or
  \index{handler>register} is much faster than using \keyname{.pgfmath}.
\end{advise}

\indexitem{handler>wrap value}|=|\meta{macro definition}

The result is the (single) expansion of the given
  \meta{macro definition}.  The defined macro takes one parameter.  The current value of the
  handled option will be passed as that parameter.
  
\indexitem{handler>wrap $n$ pgfmath args}|=|\meta{macro definition}\meta{arg $1$}\dots\meta{arg $n$}

  The result is the (single) expansion of the given \meta{macro definition}.  The defined macro
  takes $n$ parameters, where $n\in\{2,\dots,8\}$.  Expressions \meta{arg $1$} to \meta{arg $n$}
  are evaluated using |pgfmath| and passed as arguments to the defined macro.
  
\indexitem{handler>wrap pgfmath arg}|=|\meta{macro definition}\meta{arg}

  Like  \index{wrap $n$ pgfmath args} would work for $n=1$.

\indexitem{handler>process args}|=|\meta{argument types}\meta{arg $1$}\dots\meta{arg $n$}

  The result is a list of processed arguments.  Arguments 
  are processed individually according to their given type.  The types are given sequentially in
  \meta{argument types}, one character (no spaces) for each argument.  The meanings of the characters are given in the table below.  The exception to the one character -- one argument rule are characters
  connected by |+|, which apply iteratively (in the given order) to a single argument.  If the
  argument type list is shorter than the number of argument, the remaining arguments are assumed to
  require no processing.  
  
  \begin{tabular}{ll}
    |__|&no processing\\
    |o|&expand once\\
    |x|&fully expand\\
    |O|&argument is an option name\\
    |R|&argument is a register name\\
    |P|&argument is a pgfmath expression\\
    |r|&the argument should be a comma-separated list: reverse it\\
    |+|&chain processors)\\
  \end{tabular}

  Example: \index{split option} is defined by preprocessing the first argument of \index{split}
  as an option.
\lstinputregion{forest.dtx}{split_option}

\begin{forestexample}[index={delay,append,strequal,split,process args}]
  \begin{forest}
    [
      {1,2,3,4,5},
      delay={
        my append/.style={if={strequal("#1","")}{}{append={[#1]}}},
        split/.~process args~={O+r}{content}{,}{my append},
      }    
      ]
  \end{forest}
\end{forestexample}

\end{syntax}

\subsubsection{Aggregate functions}
\label{ref:aggregate-functions}

Aggregate functions are defined as handlers over options.  They walk a nodewalk, use the values of visited options to calculate something, and store the result in the handled option.

Aggregate functions cannot be nested.

\begin{syntax}
  \indexitem{aggregate>count}|=|\meta{nodewalk}

  Store the number of nodes visited in the nodewalk into the handled option.
  
\indexitem{aggregate>sum}|=|\meta{pgfmath}\meta{nodewalk}\itemnosep
\indexitem{aggregate>average}|=|\meta{pgfmath}\meta{nodewalk}\itemnosep
\indexitem{aggregate>product}|=|\meta{pgfmath}\meta{nodewalk}\itemnosep
\indexitem{aggregate>min}|=|\meta{pgfmath}\meta{nodewalk}\itemnosep
\indexitem{aggregate>max}|=|\meta{pgfmath}\meta{nodewalk}

  Calculate the value of \meta{pgfmath} expression at each visited node. Store the sum / average / product / minimum / maximum of these values into the handled option.

\indexitem{aggregate>aggregate}|=|\meta{pgfmath: start value}\meta{pgfmath: every step}\meta{pgfmath: after walk}\meta{nodewalk}

  The generic aggregate function.  First, the result is set to \meta{pgfmath: start value}.  Then,
  the given nodewalk is walked.  After each step of the \meta{nodewalk}, \meta{pgfmath: every step} expression is evaluated in the context of the new current node and stored as the result.  After the walk, the current node is reset to the origin.  \meta{pgfmath: after walk} expression is then evaluated in its context and stored as the result.

  Use (appropriately escaped) |#1| to refer to the current value of the result in \meta{pgfmath:
    every step} and \meta{pgfmath: after walk}.  Use count register \index{aggregate n} to refer
  to the current step number (in \meta{pgfmath: every step}) or the total number of steps (in \meta{pgfmath: after walk})

  Example 1: see \index{option>s}.

  Example 2: the definition of \index{aggregate>average} below.  Note that as we are using
  |.aggregate| inside a style definition, |##1| must be used to refer to the current value of the
  result.
\begin{lstlisting}[]
  /handlers/~.average~/.style 2 args={
    /handlers/~.aggregate~=
      {0}
      {(##1)+(#1)}
      {##1/\forestregister{aggregate n}}
      {#2}
  }
\end{lstlisting}
  Example 3: randomly generate the content of leaves; the content of a parent is the sum of it's children's content.
  
\begin{forestexample}[index={delay,aggregate postparse,for step,tree children-first,if option,n children,content,pgfmath,sum,step>children}]
  \begin{forest}
    delay={
      aggregate postparse=int,
      for tree children-first={
        if n children=0
          {content/.pgfmath={random(0,100)}}
          {content/~.sum~={content}{children}}
      }
    }
    [[[[][]][]][[][][[][][]]][[][[][]]]]
  \end{forest}
\end{forestexample}
  
\indexitem{register>aggregate n}|=|\meta{count}
  In the every-step expression of an aggregate function, refers to the (real) step number in the aggregate's \meta{nodewalk}.  In the after-walk expression, refers to the total number of (real) steps made.

\indexitem{node key>aggregate postparse}|=|\alternative{none,int,print,macro}

  Roughly speaking, how should the result be formatted? For details, see \citep[\S89]{tikzpgf3.0.0}.

  \begin{syntax}
  \item\indexdef{value=aggregate postparse>none}
    No formatting.
  \item\indexdef{value=aggregate postparse>int}
    The result is an integer.
  \item\indexdef{value=aggregate postparse>print}
    Use |pgf|'s number printing extension, see \citep[\S93]{tikzpgf3.0.0}.
  \item\indexdef{value=aggregate postparse>macro}
    Use a custom macro.  Specify the macro using \indexdef{node key>aggregate postparse macro}|=|\meta{cs}.
  \end{syntax}
  
\end{syntax}


\subsection{Relative node names}
\label{ref:relative-node-names}

\begin{syntax}
\indexitem{meta>relative node name}|=|[\meta{forest node name}][\indexdef[set={code}]>{!}\meta{nodewalk}]

  \meta{relative node name} refers to the \foRest; node at the end of the \meta{nodewalk}
  starting at node named \meta{forest node name}.  If \meta{forest node name} is omitted, the walk
  starts at the current node.  If \meta{nodewalk} is omitted, the ``walk'' ends at the start
  node.   (Thus, an empty \meta{relative node name} refers to the current node.)

  The \meta{nodewalk} inherits its history from the outer nodewalk (if there is one).  Its every-step
  keylist is empty.
\end{syntax}

Relative node names can be used in the following contexts:
\begin{itemize}
\item \FoRest;'s |pgfmath| option functions (\S\ref{ref:pgfmath}) take a relative node name as
  their argument, e.g.\ |content("!u")| and |content("!parent")| refer to the content of the
  parent node.
\item An option of a non-current node can be set by \meta{relative node name}|.|\meta{option
  name}|=|\meta{value}, see \S\ref{sec:option-setting}.
\item The |forest| coordinate system, both explicit and implicit; see \S\ref{ref:forest-cs}.
\end{itemize}

\subsection{The \texttt{forest} coordinate system}
\label{ref:forest-cs}

Unless package options \index{tikzcshack} is set to |false|, \TikZ;'s implicit node coordinate
system \citep[\S13.2.3]{tikzpgf2.10} is hacked to accept relative node names.\footnote{Actually,
the hack can be switched on and off on the fly, using \cmdname{i}\keyname{foresttikzcshack}.}.

The explicit \texttt{forest} coordinate system is called simply |forest| and used like this:
|(forest_cs:|\meta{forest cs spec}|)|; see \citep[\S13.2.5]{tikzpgf2.10}.  \meta{forest cs spec}
is a keylist; the following keys are accepted.

\begin{syntax}
\indexitem{forest cs>name}|=|\meta{node name}  The node with the given name becomed the current node.  The
resulting point is its (node) anchor.
\indexitem{forest cs>id}|=|\meta{node id}  The node with the given name becomed the current node. The
resulting point is its (node) anchor.
\indexitem{forest cs>go}|=|\meta{nodewalk} Walk the given nodewalk, starting at the current node.  The
  node at the end of the walk becomes the current node.  The resulting point is its (node) anchor.
  The embedded \meta{nodewalk} inherits history from the outer nodewalk.
\indexitem{forest cs>anchor}|=|\meta{anchor}  The resulting point is the given anchor of the current node.
\indexitem{forest cs>l}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{forest cs>s}|=|\meta{dimen}  Specify the \index{option>l} and \index{option>s}
coordinate of the resulting point.

The coordinate system is the node's ls-coordinate system: its origin is at its (node) anchor; the
l-axis points in the direction of the tree growth at the node, which is given by option
\index{grow};  the s-axis is orthogonal to the l-axis; the positive side is in the
counter-clockwise direction from |l| axis.

The resulting point is computed only after both \index{option>l} and \index{option>s} were given. 
\item Any other key is interpreted as a \index{relative node name}[.\meta{anchor}].
\end{syntax}


\subsection{Anchors}
\label{sec:anchors}

\FoRest; defines several anchors which can be used with any \TikZ; node belonging to a \FoRest;
tree (manually added \TikZ; nodes are thus excluded).

\begin{syntax}
\indexitem{anchor>parent anchor}\itemnosep
\indexitem{anchor>child anchor}\itemnosep
\indexitem{anchor>anchor}

  These anchors point to coordinates determined by node options \index{option>parent anchor},
  \index{option>child anchor} and \index{option>anchor}.

\indexitem{anchor>parent}, \indexdef{anchor>parent'}\itemnosep
\indexitem{anchor>parent first}, \indexdef{anchor>parent first'}\itemnosep
\indexitem{anchor>first}, \indexdef{anchor>first'}\itemnosep
\indexitem{anchor>children first}, \indexdef{anchor>children first'}\itemnosep
\indexitem{anchor>children}, \indexdef{anchor>children}\itemnosep
\indexitem{anchor>children last}, \indexdef{anchor>children last}\itemnosep
\indexitem{anchor>last}, \indexdef{anchor>last}\itemnosep
\indexitem{anchor>parent last}, \indexdef{anchor>parent last}
Growth direction based anchors.

  \TikZ;'s ``compass anchors'' |east|, |north| etc.\ resolve to coordinates on the border of the
  node facing east, north etc.\ (for the shapes that define these anchors).  The above \FoRest;'s
  anchors are similar in that they also resolve to coordinates on the border of the node.  However,
  the ``cardinal directions'' are determined by the \index{grow}th direction of the tree in the node, so
  that
  \begin{itemize}
  \item anchor |parent| faces the parent node (or, in case of the root, where the parent would be);
  \item anchor |children| faces the children (or, in case of a node without children, where the children would be);
  \item anchor |first| faces the first child (or \dots\ you get it, right?);
  \item anchor |last| faces the last child (or \dots\ you know!).
  \end{itemize}
  Combinations like |parent_children| work like combinations of compass directions, e.g.\
  |north_west|.  These anchors work as expected even if the node is \index{rotate}d, or if the
  children are \index{reversed}.

  The |'| variants refer precisely to
  the point where the cardinal growth direction intersects the border.  Variants without |'| snap to
  the closest compass anchor of the node.

  For simple examples, see definitions of \index{sn edges} and \index{roof}; for more involved
  examples, see the \reflibrary{edges} library.
\end{syntax}

\subsection{Additional \texttt{pgfmath} functions}
\label{ref:pgfmath}

For every option and register, \foRest; defines a |pgfmath| function with the same name, with the
proviso that the name might be mangled in order to conform to |pgfmath|'s naming rules. Specifically, 
all non-alphanumeric characters in the option/register name and the initial number, if
the name starts with one, are replaced by an underscore |__| in the |pgfmath| function name.

Pgfmath functions corresponding to options take one argument, a \index{relative node name}
(see~\S\ref{ref:relative-node-names}) expression, making it possible to refer to option values of
non-current nodes.  The \meta{relative node name} expression must be enclosed in double quotes in
order to 
prevent pgfmath evaluation: for example, to refer to the content of the parent, write
\index{content}|("|\index>{!}|u")|.  To refer to the option of the current node, use empty parentheses:
\index{content}|()|.\footnote{In most cases, the parentheses are optional, so \texttt{content}
is ok.  A known case where this doesn't work is preceding an operator: \texttt{l+1cm} will fail.}

If the \index{relative node name} resolves to the invalid node, these functions will an return empty
token list (for \meta{toks} options), 0pt (for \meta{dimen} options) or 0 (for \meta{count}
options).

Note that the nodewalk in the relative node name inherits its history from the outer nodewalk (if
there is one), so strange but useful constructions like the following are possible.

\begin{forestexample}[index={tikz,wrap pgfmath arg,nodewalk,back,b,ancestors,register>every step}]
  \begin{forest}
    for tree={no edge},
    before typesetting nodes={
      for nodewalk={
        c,
        every step={
          tikz/.wrap pgfmath arg=
            {\draw[<-] ()--(#1);}
            {name("~!b~")}
          },
        21{up1},ancestors
      }{}
    },
    [1[2[3]][4[5]]]
  \end{forest}  
\end{forestexample}

Boolean function \indexdef{pgfmath>valid} returns true if the node's \index{option>id}$\neq0$, i.e.\ if the node is a real, valid node; see \S\ref{ref:spatial-propagators} and \S\ref{ref:nodewalks}.  Boolean function \indexdef{pgfmath>invalid} is a negation of |valid|.

\begin{syntax}
\indexitem[set={+format={detokenize}}]{pgfmath>min_l}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)| \itemnosep
\indexitem[set={+format={detokenize}}]{pgfmath>min_s}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)| \itemnosep
\indexitem[set={+format={detokenize}}]{pgfmath>max_l}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)| \itemnosep
\indexitem[set={+format={detokenize}}]{pgfmath>max_s}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)|

  These functions return the minimum/maximum value of \index{option>l}/\index{option>s} of node at the end of \meta{nodewalk:
    node} in the context (i.e.\ growth direction) of node at the end of \meta{nodewalk: context
    node}.
\end{syntax}

Three string functions are also added to |pgfmath|: \indexdef{pgfmath>strequal} tests the equality of
its two arguments; \indexdef{pgfmath>instr} tests if the first string is a substring of the second one;
\indexdef{pgfmath>strcat} joins an arbitrary number of strings.

\bigskip

Some random notes on |pgfmath|: \begin{enumerate*}[(i)]
\item |&&|, \verb!||! and |!| are boolean ``and'', ``or'' and ``not'', respectively.
\item The equality operator (for numbers and dimensions) is |==|, \emph{not} |=|.
\end{enumerate*}  And some examples:

\begin{forestexample}[layout=tree on top,index={for step,tree,grow',calign,option>l,l sep,option>child
anchor,option>anchor,fit,tier,option>level,delay,before typesetting nodes,content,wrap $n$ pgfmath args,pgfmath},index>={!}]
  \begin{forest}
    for tree={grow'=0,calign=first,l=0,l sep=2em,child anchor=west,anchor=base
      west,fit=band,tier/.pgfmath=~level~()},
    fullpath/.style={if n=0{}{content/.wrap 2
        pgfmath args={##1/##2}{~content~("!u")}{~content~()}}},
    delay={for tree=fullpath,content=/},
    before typesetting nodes={for tree={content=\strut#1}}
    [
      [home
        [joe
          [\TeX]]
        [saso
          [\TeX]]
        [a user with a long name
          [\TeX]]]
      [usr]]
  \end{forest}
\end{forestexample}

\begin{forestexample}[point=instr,index={delay,for step,tree,conditional>if,content,n children}]
  % mark non-phrasal terminal nodes
  \begin{forest}
    delay={for tree={if=
      {!instr("P",~content~) && ~n_children~==0}
      {fill=yellow}
      {}
    }}
    [CP[DP][C'[C][TP[DP][T'[T][VP[DP][V'[V][DP]]]]]]]
  \end{forest}
\end{forestexample}

\begin{forestexample}[point=instr,index={where option,n children,tier,content,no edge,tikz},index>={!}]
  % roof terminal phrases
  \begin{forest}
    where n children=0{tier=word,
      if={~instr~("P",~content~("!u"))}{no edge,
        tikz={\draw (!.north west)--
        (!.north east)--(!u.south)--cycle;
      }}{}
    }{},
    [VP[DP[Mary]][V'[V[loves]][DP[her cat]]]]
  \end{forest}
\end{forestexample}


\subsection{Standard node}
\label{ref:standard-node}

\begin{syntax}
\indexitem{macro>forestStandardNode}\meta{node}\meta{environment fingerprint}\meta{calibration
  procedure}\meta{exported options}

  This macro defines the current \emph{standard node}.  The standard node declares some options as
  \emph{exported}.  When a new node is created, the values of the exported options are initialized
  from the standard node.  At the beginning of every \index{forest} environment, it is checked whether
  the \emph{environment fingerprint} of the standard node has changed.  If it did, the standard
  node is \emph{calibrated}, adjusting the values of exported options.  The \emph{raison d'etre} for
  such a system is given in \S\ref{tut:defaults}.

  In \meta{node}, the standard node's content and possibly other options are specified, using the
  usual bracket representation.  The \meta{node}, however, \emph{must not contain children}.  The
  default: \texttt{[dj]}.

  The \meta{environment fingerprint} must be an expandable macro definition.  It's expansion
  should change whenever the calibration is necessary.

  \meta{calibration procedure} is a keylist (processed in the |/forest| path) which calculates the
  values of exported options.

  \meta{exported options} is a comma-separated list of exported options.

  This is how the default standard node is created:
\begin{lstlisting}
  \forestStandardNode[dj]
    {%
      \forestOve{\csname forest@id@of@standard node\endcsname}{content},%
      \the\ht\strutbox,\the\pgflinewidth,%
      \pgfkeysvalueof{/pgf/inner ysep},\pgfkeysvalueof{/pgf/outer ysep},%
      \pgfkeysvalueof{/pgf/inner xsep},\pgfkeysvalueof{/pgf/outer xsep}%
    }
    {
      l sep={\the\ht\strutbox+\pgfkeysvalueof{/pgf/inner ysep}},
      l={l_sep()+abs(max_y()-min_y())+2*\pgfkeysvalueof{/pgf/outer ysep}},
      s sep={2*\pgfkeysvalueof{/pgf/inner xsep}}
    }
    {l sep,l,s sep}
  \end{lstlisting}
\end{syntax}

\subsection{Externalization}
\label{ref:externalization}

Externalized tree pictures are compiled only once. The result of the compilation is saved into a
separate |.pdf| file and reused on subsequent compilations of the document.  If the code of the
tree (or the context, see below) is changed, the tree is automatically recompiled.

Externalization is enabled by:
\begin{lstlisting}
  \usepackage[~external~]{forest}
  ~\tikzexternalize~
\end{lstlisting}
Both lines are necessary.  \TikZ;'s externalization library is automatically loaded if necessary.

\begin{syntax}
\indexitem{node key>external/optimize} Parallels \keyname{/tikz/external/optimize}: if |true| (the
default), the processing of non-current trees is skipped during the embedded compilation.
\indexitem{node key>external/context} If the expansion of the macro stored in
this option changes, the tree is recompiled.
\indexitem{node key>external/depends on macro}|=|\meta{cs} Adds the definition of macro \meta{cs} to
\keyname{external/context}.  Thus, if the definition of \meta{cs} is changed, the tree will be
recompiled. 
\end{syntax}

\foRest; respects or is compatible with several (not all) keys and commands of \TikZ;'s
externalization library.  In particular, the following keys and commands might be useful; see
\cite[\S32]{tikzpgf2.10}.
\begin{itemize}
\item\keyname{/tikz/external/remake next}
\item\keyname{/tikz/external/prefix}
\item\keyname{/tikz/external/system call}
\item\cmdname{tikzexternalize}
\item\cmdname{tikzexternalenable}
\item\cmdname{tikzexternaldisable}
\end{itemize}
\FoRest; does not disturbe the externalization of non-\foRest; pictures. (At least it
shouldn't \dots)

The main auxiliary file for externalization has suffix |.for|.  The externalized pictures have
suffices |-forest-|$n$ (their prefix can be set by \keyname{/tikz/external/prefix}, e.g.\ to a
subdirectory).  Information on all trees that were ever externalized in the document (even if
they were changed or deleted) is kept.  If you need a ``clean'' |.for| file, delete it and
recompile.  Deleting |-forest-|$n$|.pdf| will result in recompilation of a specific tree.

Using \keyname{draw tree} and \keyname{draw tree'} multiple times \emph{is} compatible with
externalization, as is drawing the tree in the box (see \index{draw tree box}).  If you are
trying to externalize a \index{forest} environment which utilizes \index{TeX} to produce a
visible effect, you will probably need to use \index{TeX'} and/or \index{TeX''}.

\setcounter{CodelineNo}{0}
\DocInput{forest-libs.dtx}

\section{Gallery}
\label{sec:gallery}

\subsection{Decision tree}
\label{sec:example-decision-tree}

The following example was inspired by a question on \TeX\ Stackexchange:
\href{http://tex.stackexchange.com/questions/39103/how-to-change-the-level-distance-in-tikz-qtree-for-one-level-only}{How to change the level distance in tikz-qtree for one level only?}.  The question is about |tikz-qtree|: how to adjust the level distance for the first level only, in order to avoid first-level labels crossing the parent--child edge.  While this example solves the problem (by manually shifting the offending labels; see \texttt{elo} below), it does more: the preamble is setup so that inputing the tree is very easy.

\begin{forestexample}[layout=tree on top,index={if option,option>n,no edge,tikz,strequal,strcat,option>child anchor,option>parent
anchor,option>anchor,anchor>anchor,calign,for step,tree,s sep,option>l,n children,declare toks,delay,content,before typesetting nodes,descendants,keylist+=tikz,wrap pgfmath arg,wrap $n$ pgfmath args,split option},index>={!}]
  \forestset{
    declare toks={elo}{}, % Edge Label Options
    anchors/.style={anchor=#1,child anchor=#1,parent anchor=#1},
    dot/.style={tikz+={\fill (.child anchor) circle[radius=#1];}},
    dot/.default=2pt,
    decision edge label/.style n args=3{
      edge label/.expanded={node[midway,auto=#1,anchor=#2,\forestoption{elo}]{\strut$\unexpanded{#3}$}}
    },
    decision/.style={if n=1
      {decision edge label={left}{east}{#1}}
      {decision edge label={right}{west}{#1}}
    },
    decision tree/.style={
      for tree={
        s sep=0.5em,l=8ex,
        if n children=0{anchors=north}{
          if n=1{anchors=south east}{anchors=south west}},
        math content,
      },
      anchors=south, outer sep=2pt,
      dot=3pt,for descendants=dot,
      delay={for descendants={~split option~={content}{;}{content,decision}}},
    }
  }
  \begin{forest} decision tree
    [N,plain content
      [I;{p_1=0.5},plain content,elo={yshift=4pt}
        [{5,1};a]
        [II;b,plain content
          [{1,2};m]
          [{2,3};n]
        ]
      ]
      [II;{p_2=0.5},plain content,elo={yshift=4pt}
        [;c
          [{1,0};z]
          [{2,2};t]
        ]
        [;d
          [{3,1};z]
          [{0,0};t]
        ]
      ] {\draw[dashed](!1.anchor)--(!2.anchor) node[pos=0.5,above]{I};}
    ]
  \end{forest}
\end{forestexample}

\setcounter{CodelineNo}{0}
\DocInput{forest-index.dtx}

\section{Past, present and future}
\label{sec:changes}

\paragraph{Roadmap}  What's planned for future releases?
\begin{itemize}
\item filling up the libraries
\item faster externalization
\item custom-edge aware packing algorithm and a more flexible (successor of) \index{calign}
\item support for specialized |forest| environments, including:
  \begin{itemize}
  \item selectable input parser,
  \item namespaces (different function, different options),
  \item better support for different output types.
  \end{itemize}
  In short, everything you need to make \foRest; your favourite spreadsheet! ;-)
\item code cleanup and extraction of sub-packages possibly useful to other package writers
\end{itemize}

\subsection{Changelog}
\label{sec:changelog}

\subsubsection{v2.0}

\begin{description}
\item[v2.0.1 (2016/02/20)] \mbox{}

  New functionality:
  \begin{itemize}
  \item \index{current and siblings}, \index{current and siblings reversed}
  \item Add |*| argument to \index{useforestlibrary}.
  \end{itemize}
  
  Bugfixes:
  \begin{itemize}
  \item Correctly mangle option/register names to pgfmath names (\S\ref{ref:pgfmath}).
  \item Refer to parent (not node) anchor in \index{calign}|=|\index{edge midpoint}.
  \item Accept key \index{history} in \index{step>Nodewalk} config.
  \end{itemize}
\item[v2.0.0 (2016/01/30)] \mbox{}\footnote{The year of the release date in the package was wrong \dots \ 2015.}
  
  Backwards incompatible changes (\emph{without} a \index{compat} key --- sorry!):
  \begin{itemize}
  \item The unintended and undocumented way to specify defaults using |\forestset{.style={...}}|
    (see question
    \href{http://tex.stackexchange.com/questions/167972/making-a-certain-tree-style-the-default-for-forest}{Making
      a certain tree style the default for forest} at \TeX\ SE) does not work anymore. (Actually, it
    has never truly worked, and that's why it has not \index{compat} key.) Use \index{default
      preamble}.
  \item Renamed augmented assignment operator \meta{option}|-| for prepending to \meta{toks} and
    \meta{keylist} options \index{+toks=\meta{option}}\index[not print]{+keylist}.  A new
    \index{keylist-=\meta{option}} is defined for keylist options and means ``delete key from keylist.''
  \item Short nodewalk steps are not simply styles anymore: use \index{define short step} to
    define them.
  \end{itemize}

  Backwards incompatible changes with a \index{compat} key:
  \lstinputregion{forest-compat.sty}{compat_1.0}

  \begin{syntax}
  \item |compat=|\indexdef{option of=compat>1.0-stages}
    
    Processing of \index{given options}, which is now exposed, and the new keylists \index{default
      preamble} and \index{preamble} is now included at the start of the default \index{stages}
    style.  When changing \index{stages}, the instruction to process these keylists must now be
    given explicitely.
    
  \item |compat=|\indexdef{option of=compat>1.0-forstep}

    In v1.0, a spatial propagator \index{for step=\meta{step}} could never fail.  This turned out to
    be difficult to debug.  In this version, when a propagator steps ``out of the tree'', an error
    is raised by default.  Check out \index{option of=Nodewalk>on invalid} to learn how to simulate
    the old behaviour without using this compatibility key.
    
  \item |compat=|\indexdef{option of=compat>1.0-rotate}

    This version of the package introduces
    option \index{rotate} and \index{autoforward}s it to \index{node options}.  This is needed to
    handle the new \foRest; anchors (\S\ref{sec:anchors}). However, in some rare cases (like the
    tree on the title page of this manual) it can lead to a discrepancy between the versions, as the
    time when the value given to \index{rotate} is processed is different. |1.0-rotate| removes
    option \index{rotate}.
    
  \item |compat=|\indexdef{option of=compat>1.0-name}

    Documentation of v1.0 requested that node names be unique, but this was not enforced by the
    package, sometimes leading to errors.  v2.0 enforces node name uniqueness. If this causes
    problems, use this compatibility key.  In most cases using \index{name'} instead of
    \index{option>name} should fix the problem without using compatibility mode.
    
  \item These keys have been renamed:
    
    \begin{tabularx}{\linewidth}{lll}
      old&new&\index{compat} key\\\hline
      \keyname{node walk}&\index{for step=nodewalk}\footnote{Nodewalks are much improved in v2.0, so some syntax and keys are different than in v1.0!}&\indexdef{option of=compat>1.0-nodewalk}\\
      \keyname{for}&\index{for step=\index{group}}&\indexdef{option of=compat>1.0-for}\\
      \keyname{for all next}&\index{for step=\index{following siblings}}&\indexdef{option of=compat>1.0-forall}\\
      \keyname{for all previous}&\index{for step=\index{preceding siblings}}&\indexdef{option of=compat>1.0-forall}\\
      \keyname{for ancestors'}&\index{for step=\index{current and ancestors}}&\indexdef{option of=compat>1.0-ancestors}\\
      (\keyname{for}) \keyname{linear next}&(\index{for step}) \index{next node}&\indexdef{option of=compat>1.0-linear}\\
      (\keyname{for}) \keyname{linear previous}&(\index{for step}) \index{previous node}&\indexdef{option of=compat>1.0-linear}\\
      \keyname{triangle}&\index{roof} (library \reflibrary{linguistics})&\indexdef{option of=compat>1.0-triangle}\\
      \keyname{/tikz/fit to tree}&\index{fit to}\keyname{=}\index{tree}\footnote{The v1.0 key \keyname{/tikz/fit to tree} also set \keyname{inner sep=0}; the v2.0 key \index{fit to} does not do that.}&\indexdef{option of=compat>1.0-fittotree}\\
      \keyname{begin forest}, \keyname{end forest}&none (use \index{stages}&\index{1.0-stages}\\
      \keyname{end forest}, \keyname{end forest}&none (use \index{stages}&\index{1.0-stages}\\
    \end{tabularx}
  \end{syntax}

  Good news:
  \begin{itemize}
  \item Added temporal propagators \index{before packing node} and \index{after packing node}.
  \item \emph{Much} improved nodewalks, see \S\ref{ref:nodewalks} and \S\ref{ref:spatial-propagators}.
  \item Implemented looping mechanisms and more conditionals, see \S\ref{ref:conditionals}.
  \item Implemented library support and started filling up the libraries:
    \begin{itemize}
    \item \reflibrary{linguistics}: \index{sn edges}, \index{nice empty nodes}, \index{draw
        brackets}, \index{c-commanded} and \index{c-commanders}
    \item \reflibrary{edges}: \index{forked edges} and \index{folder}
    \end{itemize}
  \item Implemented aggregate functions, see \S\ref{ref:aggregate-functions}.
  \item Added key \index{default preamble}.
  \item Implemented anchors \index{anchor>parent}, \index{anchor>children}, \index{anchor>first},
    \index{anchor>last}, etc.
  \item Added key \index{split} and friends.
  \item Implemented sorting of children, see \S\ref{ref:dynamic}.
  \item Introduced registers, see \S\ref{sec:options-and-registers}.
  \item Implemented handlers \index{handler>option}, \index{handler>register} and \index{process args}.
  \item Implemented several friends to \index{process keylist}, introduced \index{processing order}s
    and \index{draw tree method}.
  \item Added the optional argument |(|\meta{stages}|)| to the \index{forest} environment and
    \index{Forest} macro.
  \item Implemented \index{autoforward}ing.
  \item Implemented flexible handling of unknown keys using \index{unknown to}.
  \item Implemented |pgfmath| functions \index{pgfmath>min_l}, \index{pgfmath>max_l}, \index{pgfmath>min_s}, \index{pgfmath>max_s}.
  \item Implemented augmented assignment operator \index{keylist-=\meta{keylist option}} for removing keys from keylists.
  \item Implemented a generalized \index{fit to} key.
  \item Implemented a very slow \foRest;-based indexing system (used to index this documentation)
    and included it in the gallery (\S\ref{sec:forest-index}).
  \item Added some minor keys: \index{edge path'}, \index{node format'}, \index{create'} and \index{plain content}.
  \item Added some developer keys: \index{copy command key}, \index{typeout}.
  \end{itemize}
  
  Bugfixes:
  \begin{itemize}
  \item In computation of numeric tree-structure info, when called for a non-root node.
  \item \TikZ;'s externalization internals (signature of
    |\tikzexternal@externalizefig@systemcall@uptodatecheck|) have changed: keep up to date,
    though only formally.
  \item \index{delay} was not behaving additively.
  \item \index{option>name}, \index{alias} and \index{baseline} didn't work properly when
    setting them for a non-current node.
  \item Augmented assignments for count options were leaking `.0pt'.
  \item \index{create} didn't work properly in some cases.
  \item \keyname{triangle} (now \index{roof} in \reflibrary{linguistics}) didn't use |cycle| in the edge path
  \end{itemize}

\end{description}

\subsubsection{v1.0}
  
\begin{description}
\item[v1.0.10 (2015/07/22)] \mbox{}
  \begin{compactitem}
  \item Bugfix: a left-over debugging |\typeout| command was interfering with a |forest| within |tabular|, see \href{http://tex.stackexchange.com/questions/256509/odd-incompatibility-between-multi-line-forest-nodes-and-tabular}{this question on TeX.SE}.
  \item A somewhat changed versioning scheme \dots
  \end{compactitem}
\item[v1.09 (2015/07/15)] \mbox{}
  \begin{compactitem}
  \item Bugfix: child alignment was not done in nodes with a single child, see \href{http://tex.stackexchange.com/questions/255309/elementary-forest-question-meaning-of-calign-parent-anchor-and-child-anchor}{this question on TeX.SE}.
  \end{compactitem}
\item[v1.08 (2015/07/10)] \mbox{}
  \begin{compactitem}
  \item Fix externalization (compatibility with new |tikz| features).
  \end{compactitem}
\item[v1.07 (2015/05/29)] \mbox{}
  \begin{compactitem}
  \item Require package |elocalloc| for local boxes, which were previously defined by package |etex|.
  \end{compactitem}
\item[v1.06 (2015/05/04)] \mbox{}
  \begin{compactitem}
  \item Load |etex| package: since v2.1a, |etoolbox| doesn't do it anymore.
  \end{compactitem}
\item[v1.05 (2014/03/07)] \mbox{}
  \begin{compactitem}
  \item Fix the node boundary code for rounded rectangle.  (Patch contributed by Paul Gaborit.)
  \end{compactitem}
\item[v1.04 (2013/10/17)] \mbox{}
  \begin{compactitem}
  \item Fixed an \href{http://tex.stackexchange.com/questions/138986/error-using-tikzexternalize-with-forest/139145}{externalization bug}.
  \end{compactitem}
\item[v1.03 (2013/01/28)] \mbox{}
  \begin{compactitem}
  \item Bugfix: options of dynamically created nodes didn't get processed.
  \item Bugfix: the bracket parser was losing spaces before opening braces.
  \item Bugfix: a family of utility macros dealing with affixing token lists was not expanding
    content correctly.
  \item Added style \index{math content}.
  \item Replace key \keyname{tikz preamble} with more general \index{begin draw} and
    \index{end draw}.
  \item Add keys \keyname{begin forest} and \keyname{end forest}.
  \end{compactitem}
\item[v1.02 (2013/01/20)] \mbox{}
  \begin{compactitem}
  \item Reworked style \index{stages}: it's easier to modify the processing flow now.
  \item Individual stages must now be explicitely called in the context of some (usually root)
    node. 
  \item Added \index{delay n} and \index{if have delayed}.
  \item Added (experimental) \index{pack'}.
  \item Added reference to the \href{https://github.com/sasozivanovic/forest-styles}{style
    repository}.
  \end{compactitem}
\item[v1.01 (2012/11/14)] \mbox{}

  \begin{compactitem}
  \item Compatibility with the |standalone| package: temporarily disable the effect of
    |standalone|'s package option |tikz| while typesetting nodes.
  \item Require at least the [2010/08/21] (v2.0) release of package |etoolbox|.
  \item Require version [2010/10/13] (v2.10, rcs-revision 1.76) of \PGF;/\TikZ;.  Future
    compatibility: adjust to the change of the ``not yet positioned'' node name (2.10 |@|
    $\rightarrow$ 2.10-csv |PGFINTERNAL|).
  \item Add this changelog.
  \end{compactitem}
\item[v1.0 (2012/10/31)] First public version
\end{description}


\paragraph{Acknowledgements} 
Many thanks to the \href{http://tex.stackexchange.com}{\TeX\ SE community} and all the people who
have provided comments, sent patches and/or reported bugs!  I can happily report that the list grows
too fast to maintain \dots\@ I'll rather work on the package! ;-) And anyway, you know who you are
\dots\@ thanks!

\subsection{Known bugs}
\label{sec:bugs}

If you find a bug (there are bound to be some \dots), please contact
me at \href{mailto:saso.zivanovic@guest.arnes.si}{saso.zivanovic@guest.arnes.si}.

\subsubsection*{System requirements}

This package requires \LaTeX\ and e\TeX.  If you use something
else: sorry.

The requirement for \LaTeX\ might be dropped in the future, when I get some time and energy for a
code-cleanup (read: to remedy the consequences of my bad programming practices and general
disorganization).

The requirement for e\TeX\ will probably stay.  If nothing else, \foRest; is heavy on boxes: every
node requires its own \dots\ and consequently, I have freely used e\TeX\ constructs in the code
\dots

\subsubsection*{\PGF; internals}

\FoRest; relies on some details of \PGF; implementation, like the name
of the ``not yet positioned'' nodes.  Thus, a new bug might appear with the development of \PGF;.
If you notice one, please let me know.

\subsubsection*{Edges cutting through sibling nodes}
\label{sec:cutting-edge}

In the following example, the R--B edge crosses the AAA node, although \index{ignore edge} is
set to the default |false|.
\begin{forestexample}[index={calign,{value=calign>first},align,{value=align>center},base,{value=base>bottom}}]
  \begin{forest}
    calign=first
    [R[AAAAAAAAAA\\AAAAAAAAAA\\AAAAAAAAAA,align=center,base=bottom][B]]
  \end{forest}
\end{forestexample}
This happens because s-distances between the adjacent children are
computed before child alignment  (which is obviously the correct order in the general case), but
child alignment non-linearly influences the edges.  Observe that the with a different value of
\index{calign}, the problem does not arise. 
\begin{forestexample}[index={calign,{value=calign>last},align,{value=align>center},base,{value=base>bottom}}]
  \begin{forest}
    calign=last
    [R[AAAAAAAAAA\\AAAAAAAAAA\\AAAAAAAAAA,align=center,base=bottom][B]]
  \end{forest}
\end{forestexample}
While it would be possible to fix the situation after child alignment (at least for some child
alignment methods), I have decided against that, since the distances between siblings would soon
become too large.  If the AAA node in the example above was large enough, B could easily be pushed
off the paper.  The bottomline is, please use manual adjustment to fix such situations. 

\subsubsection*{Orphans}
\label{sec:orphans}

If the \index{option>l} coordinates of adjacent children are too different (as a result of manual adjustment or
tier alignment), the packing algorithm might have nothing so say about the desired distance
between them: in this sense, node C below is an ``orphan.'' 
\begin{forestexample}[index={for step,tree,s sep,option>l,dimen*}]
  \begin{forest}
    for tree={s sep=0,draw},
    [R[A][B][C,l*=2][D][E]]
  \end{forest}
\end{forestexample}
To prevent orphans from ending up just anywhere, I have decided to vertically align them with
their preceding sibling --- although I'm not certain that's really the best solution.  In other
words, you can rely that the sequence of s-coordinates of siblings is non-decreasing.

The decision also influences a similar situation illustrated below.  The packing algorithm puts
node E immediately next to B (i.e.\ under C): however, the monotonicity-retaining mechanism then
vertically aligns it with its preceding sibling, D.
\begin{forestexample}[index={for step,tree,s sep,tier}]
  \begin{forest}
    for tree={s sep=0,draw},
    [R[A[B,tier=bottom]][C][D][E,tier=bottom]]
  \end{forest}
\end{forestexample}

Obviously, both examples also create the situation of an edge crossing some sibling node(s).
Again, I don't think anything sensible can be done about this, in general.


\addcontentsline{toc}{section}{References}
\bibliography{tex}
\bibliographystyle{plain}

\newpage
\phantomsection
\addcontentsline{toc}{section}{\indexname}
\addtocontents{toc}{\protect\setbox0=\protect\vbox{\protect\iffalse}\protect\fi}
\PrintIndex
\addtocontents{toc}{\protect\iffalse{\protect\fi}}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% fill-column: 100
%%% TeX-command-default: "Make PDF"
%%% TeX-master: t
%%% End:
